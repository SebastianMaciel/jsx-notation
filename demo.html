<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JSXN Encoder</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background: #0a0a0a;
    color: #e0e0e0;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  header {
    padding: 24px 32px 16px;
    border-bottom: 1px solid #1e1e1e;
  }

  header h1 {
    font-size: 20px;
    font-weight: 600;
    color: #fff;
    letter-spacing: -0.02em;
  }

  header h1 span { color: #666; font-weight: 400; }

  .main {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 0;
    min-height: 0;
    overflow: hidden;
  }

  .panels {
    flex: 1;
    display: grid;
    grid-template-columns: 1fr 1fr;
    min-height: 0;
    overflow: hidden;
  }

  .panel {
    display: flex;
    flex-direction: column;
    min-height: 0;
    min-width: 0;
    overflow: hidden;
    border-right: 1px solid #1e1e1e;
  }

  .panel:last-child { border-right: none; }

  .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 20px;
    border-bottom: 1px solid #1e1e1e;
    flex-shrink: 0;
  }

  .panel-label {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #888;
  }

  .panel-stat {
    font-size: 11px;
    color: #555;
    font-variant-numeric: tabular-nums;
  }

  /* CodeMirror container */
  #editor-wrap {
    flex: 1;
    overflow: hidden;
    min-height: 0;
    min-width: 0;
  }

  #editor-wrap .cm-editor {
    height: 100%;
    width: 100%;
    background: transparent;
  }

  #editor-wrap .cm-editor .cm-scroller {
    font-family: "SF Mono", "Fira Code", "JetBrains Mono", Consolas, monospace;
    font-size: 13px;
    line-height: 1.6;
    padding: 12px 0;
  }

  #editor-wrap .cm-editor .cm-content {
    padding: 0 20px;
  }

  #editor-wrap .cm-editor .cm-gutters {
    display: none;
  }

  #editor-wrap .cm-editor.cm-focused {
    outline: none;
  }

  #editor-wrap .cm-editor .cm-activeLine,
  #editor-wrap .cm-editor .cm-activeLineGutter {
    background: transparent;
  }

  .output {
    flex: 1;
    width: 100%;
    padding: 12px 20px;
    background: transparent;
    font-family: "SF Mono", "Fira Code", "JetBrains Mono", Consolas, monospace;
    font-size: 13px;
    line-height: 1.6;
    border: none;
    outline: none;
    resize: none;
    tab-size: 2;
    overflow: auto;
    white-space: pre;
    color: #d4d4d4;
  }

  .output.empty { color: #333; }

  /* JSXN syntax highlighting */
  .jsxn-header { color: #c586c0; }
  .jsxn-alias-name { color: #9cdcfe; }
  .jsxn-alias-val { color: #ce9178; }
  .jsxn-tag { color: #4ec9b0; }
  .jsxn-class { color: #dcdcaa; }
  .jsxn-id { color: #d7ba7d; }
  .jsxn-string { color: #ce9178; }
  .jsxn-expr { color: #9cdcfe; }
  .jsxn-prop-brace { color: #d4d4d4; }
  .jsxn-prop-key { color: #9cdcfe; }
  .jsxn-prop-val { color: #d4d4d4; }
  .jsxn-cond { color: #c586c0; }
  .jsxn-map { color: #c586c0; }
  .jsxn-chevron { color: #666; }
  .jsxn-pipe { color: #666; }
  .jsxn-fragment { color: #c586c0; }
  .jsxn-spread { color: #569cd6; }

  /* Examples bar */
  .examples {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    border-bottom: 1px solid #1e1e1e;
    flex-shrink: 0;
    overflow-x: auto;
  }

  .examples-label {
    font-size: 11px;
    color: #555;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    white-space: nowrap;
    margin-right: 4px;
  }

  .example-btn {
    padding: 5px 14px;
    background: #1a1a1a;
    color: #999;
    border: 1px solid #2a2a2a;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 400;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
  }

  .example-btn:hover { background: #222; color: #ccc; border-color: #444; }
  .example-btn.active { background: #fff; color: #000; border-color: #fff; font-weight: 500; }

  /* Footer */
  .footer {
    border-top: 1px solid #2a2a2a;
    background: #0f0f0f;
    flex-shrink: 0;
    padding: 28px 36px;
    display: flex;
    align-items: center;
    gap: 40px;
  }

  .footer-encode {
    flex-shrink: 0;
  }

  .footer-encode button {
    padding: 14px 36px;
    background: #fff;
    color: #000;
    border: none;
    border-radius: 10px;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    transition: opacity 0.15s;
  }

  .footer-encode button:hover { opacity: 0.85; }
  .footer-encode button:active { opacity: 0.7; }

  .footer-stats {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 36px;
  }

  .stat-block {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .stat-label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #555;
  }

  .stat-number {
    font-size: 28px;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    color: #888;
    line-height: 1;
  }

  .stat-number.green { color: #4ade80; }
  .stat-number.white { color: #e0e0e0; }

  .stat-sub {
    font-size: 12px;
    font-weight: 400;
    color: #555;
    margin-left: 2px;
  }

  .compression-bar-wrap {
    flex: 1;
    max-width: 320px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .compression-bar-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
  }

  .compression-bar-track {
    height: 10px;
    background: #1e1e1e;
    border-radius: 5px;
    overflow: hidden;
  }

  .compression-bar-fill {
    height: 100%;
    background: #4ade80;
    border-radius: 5px;
    transition: width 0.4s ease;
    width: 0%;
  }

  .banner {
    padding: 10px 20px;
    font-size: 12px;
    font-family: monospace;
    display: none;
    flex-shrink: 0;
  }

  .banner.visible { display: block; }

  .banner.error {
    background: #1a0000;
    color: #e55;
    border-top: 1px solid #300;
  }

  .banner.warning {
    background: #1a1500;
    color: #e5b750;
    border-top: 1px solid #332800;
  }

  /* Medium screens: shrink footer a bit */
  @media (max-width: 1024px) {
    .footer { padding: 20px 24px; gap: 24px; }
    .footer-stats { gap: 20px; }
    .stat-number { font-size: 22px; }
    .compression-bar-wrap { max-width: 200px; }
    .footer-encode button { padding: 12px 24px; font-size: 14px; }
  }

  /* Small screens: stack panels, reflow footer */
  @media (max-width: 700px) {
    body { height: auto; min-height: 100vh; overflow: auto; }
    .main { overflow: visible; min-height: 0; }
    .panels { grid-template-columns: 1fr; grid-template-rows: 300px 300px; }
    .panel { border-right: none; border-bottom: 1px solid #1e1e1e; }

    .footer {
      flex-direction: column;
      align-items: stretch;
      padding: 20px;
      gap: 16px;
    }

    .footer-encode { order: -1; }
    .footer-encode button { width: 100%; }

    .footer-stats {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 16px;
    }

    .compression-bar-wrap {
      max-width: 100%;
      grid-column: 1 / -1;
    }

    .stat-number { font-size: 20px; }
  }

  /* Very small screens */
  @media (max-width: 420px) {
    header { padding: 16px 16px 12px; }
    .examples { padding: 8px 12px; gap: 6px; }
    .example-btn { padding: 4px 10px; font-size: 11px; }
    .footer { padding: 16px 12px; gap: 12px; }
    .footer-stats { grid-template-columns: 1fr 1fr; gap: 12px; }
    .stat-number { font-size: 18px; }
  }
</style>
</head>
<body>

<header>
  <h1>JSXN <span>encoder</span></h1>
</header>

<div class="main">
  <div class="examples">
    <span class="examples-label">Examples</span>
  </div>
  <div class="panels">
    <div class="panel">
      <div class="panel-header">
        <span class="panel-label">JSX input</span>
        <span class="panel-stat" id="input-chars"></span>
      </div>
      <div id="editor-wrap"></div>
    </div>
    <div class="panel">
      <div class="panel-header">
        <span class="panel-label">JSXN output</span>
        <span class="panel-stat" id="output-chars"></span>
      </div>
      <div class="output empty" id="output">Click "Encode" or press Ctrl+Enter</div>
    </div>
  </div>

  <div class="banner warning" id="warning"></div>
  <div class="banner error" id="error"></div>

  <div class="footer">
    <div class="footer-encode">
      <button id="encode-btn">Encode</button>
    </div>
    <div class="footer-stats" id="stats">
      <div class="stat-block">
        <span class="stat-label">Input</span>
        <span class="stat-number white" id="stat-input">—</span>
        <span class="stat-sub">chars</span>
      </div>
      <div class="stat-block">
        <span class="stat-label">Output</span>
        <span class="stat-number white" id="stat-output">—</span>
        <span class="stat-sub">chars</span>
      </div>
      <div class="stat-block">
        <span class="stat-label">Saved</span>
        <span class="stat-number green" id="stat-saved">—</span>
        <span class="stat-sub" id="stat-saved-sub">chars</span>
      </div>
      <div class="compression-bar-wrap">
        <div class="compression-bar-header">
          <span class="stat-label">Compression</span>
          <span class="stat-number green" id="stat-pct" style="font-size:18px">—</span>
        </div>
        <div class="compression-bar-track">
          <div class="compression-bar-fill" id="compression-fill"></div>
        </div>
      </div>
      <div class="stat-block">
        <span class="stat-label">Ratio</span>
        <span class="stat-number green" id="stat-ratio">—</span>
        <span class="stat-sub">x</span>
      </div>
    </div>
  </div>
</div>

<script type="module">
  // --- CodeMirror ---
  import { EditorView, keymap } from 'https://esm.sh/@codemirror/view@6';
  import { EditorState } from 'https://esm.sh/@codemirror/state@6';
  import { javascript } from 'https://esm.sh/@codemirror/lang-javascript@6';
  import { oneDark } from 'https://esm.sh/@codemirror/theme-one-dark@6';
  import { defaultKeymap } from 'https://esm.sh/@codemirror/commands@6';
  import { syntaxHighlighting, defaultHighlightStyle, bracketMatching } from 'https://esm.sh/@codemirror/language@6';
  import { closeBrackets } from 'https://esm.sh/@codemirror/autocomplete@6';

  // --- Babel parser ---
  import { parse } from 'https://esm.sh/@babel/parser@7.26.5';

  // --- Inline encoder (same as src/, self-contained) ---

  function parseJSX(code) {
    return parse(code, {
      sourceType: 'module',
      plugins: ['jsx', 'typescript'],
      errorRecovery: true,
    });
  }

  function analyze(ast) {
    const components = new Map();
    const props = new Map();
    const classes = new Map();
    walkForAnalysis(ast.program, components, props, classes);
    return { components, props, classes };
  }

  function walkForAnalysis(node, components, props, classes) {
    if (!node || typeof node !== 'object') return;
    if (node.type === 'JSXOpeningElement') {
      const nameNode = node.name;
      if (nameNode.type === 'JSXIdentifier' && /^[A-Z]/.test(nameNode.name)) {
        components.set(nameNode.name, (components.get(nameNode.name) ?? 0) + 1);
      }
      for (const attr of node.attributes) {
        if (attr.type === 'JSXAttribute') {
          const propName = attr.name.type === 'JSXNamespacedName'
            ? `${attr.name.namespace.name}:${attr.name.name.name}`
            : attr.name.name;
          if (propName === 'className') {
            const val = attr.value;
            if (val && val.type === 'StringLiteral') {
              for (const cls of val.value.split(/\s+/).filter(Boolean)) {
                classes.set(cls, (classes.get(cls) ?? 0) + 1);
              }
            }
            continue;
          }
          if (propName !== 'id') {
            props.set(propName, (props.get(propName) ?? 0) + 1);
          }
        }
      }
    }
    for (const key of Object.keys(node)) {
      if (key === 'loc' || key === 'leadingComments' || key === 'trailingComments') continue;
      const val = node[key];
      if (Array.isArray(val)) { for (const item of val) walkForAnalysis(item, components, props, classes); }
      else if (val && typeof val === 'object' && val.type) walkForAnalysis(val, components, props, classes);
    }
  }

  function generateAliases(frequencies) {
    return { components: genCompAliases(frequencies.components), props: genPropAliases(frequencies.props), classes: genClassAliases(frequencies.classes ?? new Map()) };
  }

  function genCompAliases(freq) {
    const aliases = new Map();
    const candidates = [...freq.entries()].filter(([n]) => n.length > 1).sort((a, b) => b[1] - a[1]);
    const used = new Set();
    for (const [name] of candidates) { const a = findAlias(name, used, true); used.add(a); aliases.set(name, a); }
    return aliases;
  }

  function genPropAliases(freq) {
    const aliases = new Map();
    const candidates = [...freq.entries()].filter(([n, c]) => c >= 2 && n.length > 4).sort((a, b) => b[1] - a[1]);
    const used = new Set();
    for (const [name] of candidates) { const a = findAlias(name, used, false); used.add(a); aliases.set(name, a); }
    return aliases;
  }

  function genClassAliases(freq) {
    const aliases = new Map();
    const candidates = [...freq.entries()].filter(([n, c]) => c >= 2 && n.length > 3)
      .sort((a, b) => (b[1] * b[0].length) - (a[1] * a[0].length));
    const used = new Set();
    for (const [name] of candidates) {
      const alias = findClassAlias(name, used);
      if (alias.length < name.length) { used.add(alias); aliases.set(name, alias); }
    }
    return aliases;
  }

  function findClassAlias(name, used) {
    const segs = name.split(/[-:]/);
    let a = segs.map(s => s[0] ?? '').join('');
    if (a && !used.has(a) && a.length < name.length) return a;
    const last = segs[segs.length - 1];
    if (last.length > 1) { a = segs.map(s => s[0] ?? '').join('') + last[last.length - 1]; if (!used.has(a) && a.length < name.length) return a; }
    if (segs[0].length >= 2) { a = segs[0].slice(0, 2) + segs.slice(1).map(s => s[0] ?? '').join(''); if (!used.has(a) && a.length < name.length) return a; }
    for (let len = 2; len < name.length; len++) { a = name.replace(/[-:]/g, '').slice(0, len); if (!used.has(a) && a.length < name.length) return a; }
    return name;
  }

  function findAlias(name, used, isComp) {
    if (!isComp && name.startsWith('on') && name.length > 2) {
      const ev = name.slice(2);
      for (let i = ev.length - 1; i >= 0; i--) { const ch = ev[i].toLowerCase(); if (!used.has(ch)) return ch; }
      for (let i = 0; i < ev.length - 1; i++) { const t = ev.slice(i, i + 2).toLowerCase(); if (!used.has(t)) return t; }
    }
    const fc = isComp ? name[0].toUpperCase() : name[0].toLowerCase();
    if (!used.has(fc)) return fc;
    let a = fc;
    for (let i = 1; i < name.length; i++) { a += isComp ? name[i] : name[i].toLowerCase(); if (!used.has(a)) return a; }
    return a;
  }

  function formatHeaders(aliases) {
    const lines = [];
    if (aliases.components.size > 0) lines.push('@C ' + [...aliases.components.entries()].map(([n, a]) => `${n}=${a}`).join(', '));
    if (aliases.props.size > 0) lines.push('@P ' + [...aliases.props.entries()].map(([n, a]) => `${n}=${a}`).join(', '));
    if (aliases.classes.size > 0) lines.push('@S ' + [...aliases.classes.entries()].map(([n, a]) => `${n}=${a}`).join(', '));
    return lines.join('\n');
  }

  function emit(ast, aliases, code) {
    const ctx = { ca: aliases?.components ?? new Map(), pa: aliases?.props ?? new Map(), sa: aliases?.classes ?? new Map(), code };
    const lines = [];
    for (const stmt of ast.program.body) collectJSX(stmt, (node) => emitNode(node, 0, lines, ctx));
    return lines.join('\n');
  }

  function ind(l) { return ' '.repeat(l); }

  function collectJSX(node, cb) {
    if (!node) return;
    if (node.type === 'JSXElement' || node.type === 'JSXFragment') { cb(node); return; }
    if (node.type === 'ExpressionStatement') collectJSX(node.expression, cb);
    else if (node.type === 'ReturnStatement') collectJSX(node.argument, cb);
    else if (node.type === 'ParenthesizedExpression') collectJSX(node.expression, cb);
    else if (node.type === 'ExportDefaultDeclaration' || node.type === 'ExportNamedDeclaration') collectJSX(node.declaration, cb);
    else if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') collectJSXBlock(node.body, cb);
    else if (node.type === 'VariableDeclaration') { for (const d of node.declarations) if (d.init) collectJSX(d.init, cb); }
  }

  function collectJSXBlock(node, cb) {
    if (!node) return;
    if (node.type === 'BlockStatement') { for (const s of node.body) collectJSX(s, cb); }
    else collectJSX(node, cb);
  }

  function getTagName(n, ca) { const raw = getRawTag(n); return ca.get(raw) ?? raw; }
  function getRawTag(n) {
    if (n.type === 'JSXIdentifier') return n.name;
    if (n.type === 'JSXMemberExpression') return `${getRawTag(n.object)}.${n.property.name}`;
    if (n.type === 'JSXNamespacedName') return `${n.namespace.name}:${n.name.name}`;
    return 'unknown';
  }

  function emitNode(node, level, lines, ctx) {
    if (node.type === 'JSXFragment') { lines.push(`${ind(level)}_`); for (const c of sigChildren(node.children)) emitNode(c, level + 1, lines, ctx); return; }
    if (node.type === 'JSXText') { const t = node.value.trim(); if (t) lines.push(`${ind(level)}"${t}"`); return; }
    if (node.type === 'JSXExpressionContainer') { emitExpr(node, level, lines, ctx); return; }
    if (node.type === 'JSXSpreadChild') { lines.push(`${ind(level)}(...${ctx.code.slice(node.argument.start, node.argument.end)})`); return; }
    if (node.type !== 'JSXElement') return;

    const op = node.openingElement;
    const tag = getTagName(op.name, ctx.ca);
    let cls = null, idv = null;
    const other = [];

    for (const attr of op.attributes) {
      if (attr.type === 'JSXSpreadAttribute') { other.push({ spread: true, node: attr }); continue; }
      const pn = attr.name.type === 'JSXNamespacedName' ? `${attr.name.namespace.name}:${attr.name.name.name}` : attr.name.name;
      if (pn === 'className') { cls = attrVal(attr, ctx.code); continue; }
      if (pn === 'id') { idv = attrVal(attr, ctx.code); continue; }
      other.push({ propName: pn, attr });
    }

    const hasSel = idv !== null || cls !== null;
    let line = (tag === 'div' && hasSel) ? '' : tag;
    if (idv) line += idv.type === 'string' ? `#${idv.value}` : `#{${idv.value}}`;
    if (cls) {
      if (cls.type === 'string') { for (const c of cls.value.split(/\s+/).filter(Boolean)) line += `.${ctx.sa.get(c) ?? c}`; }
      else line += `.{${cls.value}}`;
    }
    const ps = fmtProps(other, ctx.pa, ctx.code);
    if (ps) line += ` ${ps}`;

    const children = sigChildren(node.children);
    if (children.length === 0) { lines.push(`${ind(level)}${line}`); }
    else if (children.length === 1 && isInline(children[0])) {
      const c = children[0];
      if (c.type === 'JSXText') lines.push(`${ind(level)}${line} "${c.value.trim()}"`);
      else if (c.type === 'JSXExpressionContainer') {
        const e = c.expression;
        lines.push(`${ind(level)}${line} ${e.type === 'StringLiteral' ? `"${e.value}"` : `(${ctx.code.slice(e.start, e.end)})`}`);
      }
    } else {
      lines.push(`${ind(level)}${line}`);
      for (const c of children) emitNode(c, level + 1, lines, ctx);
    }
  }

  function emitExpr(node, level, lines, ctx) {
    const expr = node.expression;
    if (!expr || expr.type === 'JSXEmptyExpression') return;
    if (expr.type === 'LogicalExpression' && expr.operator === '&&' && isJSXN(expr.right)) {
      const cond = ctx.code.slice(expr.left.start, expr.left.end);
      const cl = []; emitNode(unwrap(expr.right), 0, cl, ctx);
      lines.push(`${ind(level)}?${cond} > ${cl[0].trim()}`);
      for (let i = 1; i < cl.length; i++) lines.push(`${ind(level)} ${cl[i]}`);
      return;
    }
    if (expr.type === 'ConditionalExpression' && (isJSXN(expr.consequent) || isJSXN(expr.alternate))) {
      const cond = ctx.code.slice(expr.test.start, expr.test.end);
      const cn = unwrap(expr.consequent), al = unwrap(expr.alternate);
      if (isJSXN(cn) && isJSXN(al)) {
        const cl = []; emitNode(cn, 0, cl, ctx);
        const al2 = []; emitNode(al, 0, al2, ctx);
        lines.push(`${ind(level)}?${cond} > ${cl[0].trim()} | ${al2[0].trim()}`);
        return;
      }
    }
    if (isMap(expr)) { emitMap(expr, level, lines, ctx); return; }
    lines.push(`${ind(level)}(${ctx.code.slice(expr.start, expr.end)})`);
  }

  function isMap(e) { return e.type === 'CallExpression' && e.callee.type === 'MemberExpression' && e.callee.property.name === 'map' && e.arguments.length >= 1; }

  function emitMap(expr, level, lines, ctx) {
    const coll = ctx.code.slice(expr.callee.object.start, expr.callee.object.end);
    const jsx = getMapJSX(expr.arguments[0]);
    if (jsx) {
      const cl = []; emitNode(jsx, 0, cl, ctx);
      lines.push(`${ind(level)}*${coll} > ${cl[0].trim()}`);
      for (let i = 1; i < cl.length; i++) lines.push(`${ind(level)} ${cl[i]}`);
    } else lines.push(`${ind(level)}(${ctx.code.slice(expr.start, expr.end)})`);
  }

  function getMapJSX(cb) {
    if (!cb) return null;
    if (cb.type === 'ArrowFunctionExpression' || cb.type === 'FunctionExpression') {
      const b = cb.body;
      if (b.type === 'JSXElement' || b.type === 'JSXFragment') return b;
      if (b.type === 'ParenthesizedExpression') { const i = b.expression; if (i.type === 'JSXElement' || i.type === 'JSXFragment') return i; }
      if (b.type === 'BlockStatement') { for (const s of b.body) { if (s.type === 'ReturnStatement' && s.argument) { const a = unwrap(s.argument); if (a.type === 'JSXElement' || a.type === 'JSXFragment') return a; } } }
    }
    return null;
  }

  function unwrap(n) { while (n && n.type === 'ParenthesizedExpression') n = n.expression; return n; }
  function isJSXN(n) { const u = unwrap(n); return u && (u.type === 'JSXElement' || u.type === 'JSXFragment'); }
  function sigChildren(children) { return children.filter(c => c.type === 'JSXText' ? c.value.trim().length > 0 : !(c.type === 'JSXExpressionContainer' && c.expression.type === 'JSXEmptyExpression')); }

  function isInline(c) {
    if (c.type === 'JSXText') return true;
    if (c.type === 'JSXExpressionContainer') {
      const e = c.expression;
      if (e.type === 'LogicalExpression' && e.operator === '&&' && isJSXN(e.right)) return false;
      if (e.type === 'ConditionalExpression' && (isJSXN(e.consequent) || isJSXN(e.alternate))) return false;
      if (isMap(e)) return false;
      if (isJSXN(e)) return false;
      return true;
    }
    return false;
  }

  function attrVal(attr, code) {
    const v = attr.value;
    if (!v) return { type: 'boolean', value: true };
    if (v.type === 'StringLiteral') return { type: 'string', value: v.value };
    if (v.type === 'JSXExpressionContainer') {
      const e = v.expression;
      if (e.type === 'StringLiteral') return { type: 'string', value: e.value };
      return { type: 'expression', value: code.slice(e.start, e.end) };
    }
    return { type: 'string', value: String(v.value ?? '') };
  }

  function fmtProps(props, pa, code) {
    if (!props.length) return '';
    const parts = [];
    for (const p of props) {
      if (p.spread) { parts.push(`...${code.slice(p.node.argument.start, p.node.argument.end)}`); continue; }
      const alias = pa.get(p.propName) ?? p.propName;
      const val = attrVal(p.attr, code);
      if (val.type === 'boolean') { parts.push(alias); continue; }
      parts.push(`${alias}:${val.value}`);
    }
    return `{${parts.join(', ')}}`;
  }

  function hasJSX(ast) {
    let found = false;
    function walk(n) {
      if (found || !n || typeof n !== 'object') return;
      if (n.type === 'JSXElement' || n.type === 'JSXFragment') { found = true; return; }
      for (const k of Object.keys(n)) {
        if (k === 'loc' || k === 'leadingComments' || k === 'trailingComments') continue;
        const v = n[k];
        if (Array.isArray(v)) for (const i of v) walk(i);
        else if (v && typeof v === 'object' && v.type) walk(v);
        if (found) return;
      }
    }
    walk(ast.program);
    return found;
  }

  function encode(code) {
    const ast = parseJSX(code);
    const errors = ast.errors ?? [];
    if (!hasJSX(ast)) return { output: code, errors };
    const freq = analyze(ast);
    const aliases = generateAliases(freq);
    const headers = formatHeaders(aliases);
    const body = emit(ast, aliases, code);
    return { output: headers ? `${headers}\n\n${body}` : body, errors };
  }

  // --- JSXN syntax highlighter ---

  function esc(s) {
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function highlightJSXN(text) {
    return text.split('\n').map(highlightLine).join('\n');
  }

  function highlightLine(line) {
    // Header lines: @C or @P
    if (/^\s*@[CPS]\s/.test(line)) {
      return line.replace(/^(\s*@[CPS])\s(.*)$/, (_, prefix, rest) => {
        const pairs = rest.replace(/([A-Za-z][A-Za-z0-9.]*)=([A-Za-z][A-Za-z0-9]*)/g,
          (__, name, alias) => `<span class="jsxn-alias-name">${esc(name)}</span>=<span class="jsxn-alias-val">${esc(alias)}</span>`
        );
        return `<span class="jsxn-header">${esc(prefix)}</span> ${pairs}`;
      });
    }

    // Empty / whitespace-only
    if (!line.trim()) return '';

    const indent = line.match(/^(\s*)/)[1];
    const content = line.slice(indent.length);

    // Fragment _
    if (content === '_') {
      return `${indent}<span class="jsxn-fragment">_</span>`;
    }

    // Conditional: ?cond > ...
    if (content.startsWith('?')) {
      const m = content.match(/^\?(.+?)\s*>\s*(.*)$/);
      if (m) {
        const afterChevron = m[2];
        const pipeIdx = findTopLevelPipe(afterChevron);
        if (pipeIdx >= 0) {
          const left = afterChevron.slice(0, pipeIdx).trim();
          const right = afterChevron.slice(pipeIdx + 1).trim();
          return `${indent}<span class="jsxn-cond">?</span><span class="jsxn-expr">${esc(m[1])}</span> <span class="jsxn-chevron">&gt;</span> ${highlightTagPart(left)} <span class="jsxn-pipe">|</span> ${highlightTagPart(right)}`;
        }
        return `${indent}<span class="jsxn-cond">?</span><span class="jsxn-expr">${esc(m[1])}</span> <span class="jsxn-chevron">&gt;</span> ${highlightTagPart(afterChevron)}`;
      }
    }

    // Map: *collection > ...
    if (content.startsWith('*')) {
      const m = content.match(/^\*(.+?)\s*>\s*(.*)$/);
      if (m) {
        return `${indent}<span class="jsxn-map">*</span><span class="jsxn-expr">${esc(m[1])}</span> <span class="jsxn-chevron">&gt;</span> ${highlightTagPart(m[2])}`;
      }
    }

    // Pure string line: "text"
    if (/^".*"$/.test(content)) {
      return `${indent}<span class="jsxn-string">${esc(content)}</span>`;
    }

    // Pure expression line: (expr)
    if (content.startsWith('(') && content.endsWith(')')) {
      return `${indent}<span class="jsxn-expr">${esc(content)}</span>`;
    }

    // Tag line: tag#id.class.class {props} "text" or (expr)
    return indent + highlightTagPart(content);
  }

  function highlightTagPart(s) {
    // Break into: tagWithSelectors + optional props + optional trailing string/expr
    let rest = s;
    let result = '';

    // 1. Extract tag + #id + .classes (everything before first space or {)
    const selectorEnd = rest.search(/[\s{]/);
    const selectorPart = selectorEnd === -1 ? rest : rest.slice(0, selectorEnd);
    rest = selectorEnd === -1 ? '' : rest.slice(selectorEnd);

    // Highlight selector: tag#id.class1.class2
    result += highlightSelector(selectorPart);

    if (!rest) return result;

    // 2. If starts with space then {, it's props
    const trimmed = rest;
    const braceStart = trimmed.indexOf('{');

    if (braceStart >= 0) {
      // Everything before the brace is whitespace
      result += esc(trimmed.slice(0, braceStart));
      // Find matching close brace
      const braceEnd = findMatchingBrace(trimmed, braceStart);
      if (braceEnd >= 0) {
        const propsBlock = trimmed.slice(braceStart, braceEnd + 1);
        result += highlightProps(propsBlock);
        rest = trimmed.slice(braceEnd + 1);
      } else {
        result += esc(trimmed.slice(braceStart));
        rest = '';
      }
    } else {
      rest = trimmed;
    }

    // 3. Trailing string "..." or expression (...)
    if (rest.trim()) {
      const tr = rest.trimStart();
      const space = rest.slice(0, rest.length - tr.length);
      if (tr.startsWith('"')) {
        result += `${esc(space)}<span class="jsxn-string">${esc(tr)}</span>`;
      } else if (tr.startsWith('(')) {
        result += `${esc(space)}<span class="jsxn-expr">${esc(tr)}</span>`;
      } else {
        result += esc(rest);
      }
    }

    return result;
  }

  function highlightSelector(s) {
    // Split on # and . keeping delimiters
    const tokens = s.split(/(?=[#.])/);
    let out = '';
    for (let i = 0; i < tokens.length; i++) {
      const tok = tokens[i];
      if (tok.startsWith('#')) {
        out += `<span class="jsxn-id">${esc(tok)}</span>`;
      } else if (tok.startsWith('.')) {
        out += `<span class="jsxn-class">${esc(tok)}</span>`;
      } else {
        out += `<span class="jsxn-tag">${esc(tok)}</span>`;
      }
    }
    return out;
  }

  function highlightProps(block) {
    // {key:val, key:val, ...spread}
    const inner = block.slice(1, -1);
    let result = '<span class="jsxn-prop-brace">{</span>';

    // Split by top-level commas
    const parts = splitTopLevel(inner, ',');
    for (let i = 0; i < parts.length; i++) {
      if (i > 0) result += '<span class="jsxn-prop-brace">, </span>';
      const part = parts[i].trim();
      if (part.startsWith('...')) {
        result += `<span class="jsxn-spread">${esc(part)}</span>`;
      } else {
        const colonIdx = part.indexOf(':');
        if (colonIdx >= 0) {
          const key = part.slice(0, colonIdx);
          const val = part.slice(colonIdx + 1);
          result += `<span class="jsxn-prop-key">${esc(key)}</span>:<span class="jsxn-prop-val">${esc(val)}</span>`;
        } else {
          // Boolean prop
          result += `<span class="jsxn-prop-key">${esc(part)}</span>`;
        }
      }
    }

    result += '<span class="jsxn-prop-brace">}</span>';
    return result;
  }

  function findMatchingBrace(s, start) {
    let depth = 0;
    for (let i = start; i < s.length; i++) {
      if (s[i] === '{') depth++;
      else if (s[i] === '}') { depth--; if (depth === 0) return i; }
    }
    return -1;
  }

  function splitTopLevel(s, sep) {
    const parts = [];
    let depth = 0;
    let current = '';
    for (let i = 0; i < s.length; i++) {
      const ch = s[i];
      if (ch === '(' || ch === '{' || ch === '[') depth++;
      else if (ch === ')' || ch === '}' || ch === ']') depth--;
      if (ch === sep && depth === 0) {
        parts.push(current);
        current = '';
      } else {
        current += ch;
      }
    }
    if (current) parts.push(current);
    return parts;
  }

  function findTopLevelPipe(s) {
    let depth = 0;
    for (let i = 0; i < s.length; i++) {
      const ch = s[i];
      if (ch === '(' || ch === '{' || ch === '[') depth++;
      else if (ch === ')' || ch === '}' || ch === ']') depth--;
      if (ch === '|' && depth === 0) return i;
    }
    return -1;
  }

  // --- UI ---

  const EXAMPLES = [
    {
      name: 'Conditionals',
      code: `function UserProfile({ user, isLoading, error }) {
  return (
    <div className="profile-container">
      {isLoading && (
        <Spinner size="large" />
      )}
      {error && (
        <Alert type="error" onDismiss={clearError}>
          <AlertTitle>Something went wrong</AlertTitle>
          <AlertDescription>{error.message}</AlertDescription>
        </Alert>
      )}
      {user ? (
        <div className="profile-card">
          <Avatar src={user.avatar} size="xl" />
          <h2 className="profile-name">{user.name}</h2>
          <p className="profile-bio">{user.bio}</p>
          {user.isAdmin ? (
            <Badge variant="admin">Admin</Badge>
          ) : (
            <Badge variant="user">User</Badge>
          )}
        </div>
      ) : (
        <EmptyState
          title="No user found"
          description="Please log in to view your profile"
          action={<Button onClick={login}>Log In</Button>}
        />
      )}
    </div>
  );
}`,
    },
    {
      name: 'Tailwind Dashboard',
      code: `const Dashboard = () => (
  <div className="flex flex-col min-h-screen bg-gray-50">
    <header className="flex items-center justify-between px-6 py-4 bg-white shadow-sm">
      <h1 className="text-xl font-bold text-gray-900">Dashboard</h1>
      <div className="flex items-center gap-3">
        <Button className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700">
          New Project
        </Button>
        <Avatar className="w-8 h-8 rounded-full" src={user.avatar} />
      </div>
    </header>
    <main className="flex-1 p-6">
      <div className="grid grid-cols-3 gap-6 mb-8">
        {stats.map(stat => (
          <div className="p-6 bg-white rounded-lg shadow-sm">
            <p className="text-sm font-medium text-gray-500">{stat.label}</p>
            <p className="mt-2 text-3xl font-bold text-gray-900">{stat.value}</p>
          </div>
        ))}
      </div>
      <div className="bg-white rounded-lg shadow-sm">
        <div className="px-6 py-4 border-b border-gray-200">
          <h2 className="text-lg font-medium text-gray-900">Recent Activity</h2>
        </div>
        <ul className="divide-y divide-gray-200">
          {activities.map(item => (
            <li className="flex items-center justify-between px-6 py-4">
              <div className="flex items-center gap-3">
                <div className="w-8 h-8 rounded-full bg-gray-200" />
                <div>
                  <p className="text-sm font-medium text-gray-900">{item.title}</p>
                  <p className="text-sm text-gray-500">{item.time}</p>
                </div>
              </div>
              <span className="px-2 py-1 text-xs font-medium text-green-700 bg-green-100 rounded-full">
                {item.status}
              </span>
            </li>
          ))}
        </ul>
      </div>
    </main>
  </div>
)`,
    },
    {
      name: 'Form + Validation',
      code: `function CheckoutForm({ onSubmit, isProcessing }) {
  return (
    <form className="checkout-form" onSubmit={onSubmit}>
      <FormField label="Full Name" error={errors.name}>
        <Input name="name" value={values.name} onChange={handleChange} placeholder="John Doe" />
      </FormField>
      <FormField label="Email" error={errors.email}>
        <Input name="email" type="email" value={values.email} onChange={handleChange} placeholder="john@example.com" />
      </FormField>
      <FormField label="Card Number" error={errors.card}>
        <Input name="card" value={values.card} onChange={handleChange} placeholder="4242 4242 4242 4242" />
      </FormField>
      <div className="checkout-row">
        <FormField label="Expiry" error={errors.expiry}>
          <Input name="expiry" value={values.expiry} onChange={handleChange} placeholder="MM/YY" />
        </FormField>
        <FormField label="CVC" error={errors.cvc}>
          <Input name="cvc" value={values.cvc} onChange={handleChange} placeholder="123" />
        </FormField>
      </div>
      <Button type="submit" disabled={isProcessing} className="checkout-btn">
        {isProcessing ? "Processing..." : "Pay Now"}
      </Button>
    </form>
  );
}`,
    },
    {
      name: 'Simple HTML',
      code: `function LandingPage() {
  return (
    <div id="root">
      <nav>
        <a href="/">Home</a>
        <a href="/about">About</a>
        <a href="/contact">Contact</a>
      </nav>
      <main>
        <h1>Welcome to our site</h1>
        <p>This is a simple landing page with basic HTML elements.</p>
        <form>
          <label>Email</label>
          <input type="email" placeholder="you@example.com" />
          <label>Password</label>
          <input type="password" placeholder="Enter password" />
          <button type="submit">Sign In</button>
        </form>
        <img src="hero.jpg" alt="Hero image" />
      </main>
      <footer>
        <p>Copyright 2024</p>
      </footer>
    </div>
  );
}`,
    },
    {
      name: 'Component Heavy',
      code: `function App() {
  return (
    <Layout>
      <Sidebar>
        <NavItem icon={<HomeIcon />} label="Home" href="/" />
        <NavItem icon={<SettingsIcon />} label="Settings" href="/settings" />
        <NavItem icon={<ProfileIcon />} label="Profile" href="/profile" />
      </Sidebar>
      <Content>
        <PageHeader title="Welcome" subtitle="Manage your account" />
        <Card>
          <CardHeader>
            <CardTitle>Recent Orders</CardTitle>
          </CardHeader>
          <CardBody>
            {orders.map(order => (
              <OrderRow key={order.id} order={order} onSelect={handleSelect} onDelete={handleDelete} />
            ))}
          </CardBody>
          <CardFooter>
            <Button variant="primary" onClick={loadMore}>Load More</Button>
            <Button variant="ghost" onClick={handleReset}>Reset</Button>
          </CardFooter>
        </Card>
      </Content>
    </Layout>
  );
}`,
    },
  ];

  const outputEl = document.getElementById('output');
  const errorEl = document.getElementById('error');
  const warningEl = document.getElementById('warning');
  const inputCharsEl = document.getElementById('input-chars');
  const outputCharsEl = document.getElementById('output-chars');
  const encodeBtn = document.getElementById('encode-btn');
  const statInput = document.getElementById('stat-input');
  const statOutput = document.getElementById('stat-output');
  const statSaved = document.getElementById('stat-saved');
  const statSavedSub = document.getElementById('stat-saved-sub');
  const statPct = document.getElementById('stat-pct');
  const statRatio = document.getElementById('stat-ratio');
  const compressionFill = document.getElementById('compression-fill');

  // Create CodeMirror editor
  const editor = new EditorView({
    state: EditorState.create({
      doc: EXAMPLES[0].code,
      extensions: [
        keymap.of([
          ...defaultKeymap,
          { key: 'Mod-Enter', run: () => { run(); return true; } },
        ]),
        javascript({ jsx: true, typescript: true }),
        oneDark,
        bracketMatching(),
        closeBrackets(),
        EditorView.lineWrapping,
      ],
    }),
    parent: document.getElementById('editor-wrap'),
  });

  function run() {
    const code = editor.state.doc.toString();
    errorEl.classList.remove('visible');
    errorEl.textContent = '';
    warningEl.classList.remove('visible');
    warningEl.textContent = '';

    if (!code.trim()) {
      outputEl.innerHTML = '';
      outputEl.classList.add('empty');
      outputEl.textContent = 'Click "Encode" or press Cmd+Enter';
      inputCharsEl.textContent = '';
      outputCharsEl.textContent = '';
      resetStats();
      return;
    }

    try {
      const { output: result, errors } = encode(code);

      if (errors.length > 0) {
        const msgs = errors.map(e => `Line ${e.loc?.line ?? '?'}: ${e.message}`);
        warningEl.textContent = `Parse warning${errors.length > 1 ? 's' : ''}: ${msgs.join(' | ')}`;
        warningEl.classList.add('visible');
      }

      outputEl.innerHTML = highlightJSXN(result);
      outputEl.classList.remove('empty');

      const inLen = code.length;
      const outLen = result.length;
      const saved = inLen - outLen;
      const pct = inLen > 0 ? ((saved / inLen) * 100) : 0;
      const ratio = inLen > 0 ? (inLen / outLen) : 1;

      inputCharsEl.textContent = `${inLen.toLocaleString()} chars`;
      outputCharsEl.textContent = `${outLen.toLocaleString()} chars`;

      statInput.textContent = inLen.toLocaleString();
      statOutput.textContent = outLen.toLocaleString();
      statSaved.textContent = saved.toLocaleString();
      statSavedSub.textContent = 'chars';
      statPct.textContent = pct.toFixed(1) + '%';
      statRatio.textContent = ratio.toFixed(2);
      compressionFill.style.width = Math.max(0, Math.min(100, pct)) + '%';
    } catch (e) {
      errorEl.textContent = e.message;
      errorEl.classList.add('visible');
    }
  }

  function resetStats() {
    statInput.textContent = '—';
    statOutput.textContent = '—';
    statSaved.textContent = '—';
    statPct.textContent = '—';
    statRatio.textContent = '—';
    compressionFill.style.width = '0%';
  }

  function loadExample(idx) {
    const ex = EXAMPLES[idx];
    editor.dispatch({
      changes: { from: 0, to: editor.state.doc.length, insert: ex.code },
    });
    // Update active button
    document.querySelectorAll('.example-btn').forEach((btn, i) => {
      btn.classList.toggle('active', i === idx);
    });
    run();
  }

  // Build example buttons
  const examplesBar = document.querySelector('.examples');
  EXAMPLES.forEach((ex, i) => {
    const btn = document.createElement('button');
    btn.className = 'example-btn';
    btn.textContent = ex.name;
    btn.addEventListener('click', () => loadExample(i));
    examplesBar.appendChild(btn);
  });

  encodeBtn.addEventListener('click', run);

  // Load first example on startup
  loadExample(0);
</script>
</body>
</html>
