<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Live encoder and decoder for JSXN notation. Convert JSX, HTML, and SVG to compact JSXN and back.">
<meta name="theme-color" content="#0a0a0a">
<meta property="og:type" content="website">
<meta property="og:title" content="JSXN — Editor">
<meta property="og:description" content="Live encoder and decoder for JSXN notation. Convert JSX, HTML, and SVG to compact JSXN and back.">
<meta property="og:url" content="https://sebastianmaciel.github.io/jsx-notation/editor.html">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JSXN — Editor">
<meta name="twitter:description" content="Live encoder and decoder for JSXN notation. Convert JSX, HTML, and SVG to compact JSXN and back.">
<link rel="canonical" href="https://sebastianmaciel.github.io/jsx-notation/editor.html">
<title>JSXN — Editor</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Cpath d='M10,4 L2,16 L10,28' stroke='%23888' stroke-width='3' stroke-linecap='round' stroke-linejoin='round' fill='none'/%3E%3Cpath d='M22,4 L30,16 L22,28' stroke='%23888' stroke-width='3' stroke-linecap='round' stroke-linejoin='round' fill='none'/%3E%3Cpath d='M12,16 L20,16' stroke='%234ade80' stroke-width='2.5' stroke-linecap='round'/%3E%3Cpath d='M12,16 L14.5,13.5 M12,16 L14.5,18.5' stroke='%234ade80' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round' fill='none'/%3E%3Cpath d='M20,16 L17.5,13.5 M20,16 L17.5,18.5' stroke='%234ade80' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round' fill='none'/%3E%3C/svg%3E">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background: #0a0a0a;
    color: #e0e0e0;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  header {
    padding: 24px 32px 16px;
    border-bottom: 1px solid #1e1e1e;
  }

  header h1 {
    font-size: 20px;
    font-weight: 600;
    color: #fff;
    letter-spacing: -0.02em;
  }

  header h1 span { color: #666; font-weight: 400; }
  header { display: flex; align-items: center; justify-content: space-between; }
  header a { color: #555; font-size: 13px; text-decoration: none; transition: color 0.2s; }
  header a:hover { color: #fff; }

  .mode-toggle {
    display: flex;
    background: #141414;
    border: 1px solid #2a2a2a;
    border-radius: 8px;
    overflow: hidden;
    margin-left: 16px;
  }

  .mode-btn {
    padding: 6px 18px;
    background: transparent;
    color: #666;
    border: none;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
  }

  .mode-btn:hover { color: #aaa; }
  .mode-btn.active { background: #fff; color: #000; }

  .main {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 0;
    min-height: 0;
    overflow: hidden;
  }

  .panels {
    flex: 1;
    display: grid;
    grid-template-columns: 1fr 1fr;
    min-height: 0;
    overflow: hidden;
  }

  .panel {
    display: flex;
    flex-direction: column;
    min-height: 0;
    min-width: 0;
    overflow: hidden;
    border-right: 1px solid #1e1e1e;
  }

  .panel:last-child { border-right: none; }

  .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 20px;
    border-bottom: 1px solid #1e1e1e;
    flex-shrink: 0;
  }

  .panel-label {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #888;
  }

  .panel-stat {
    font-size: 12px;
    font-variant-numeric: tabular-nums;
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .panel-stat .tok-value {
    font-weight: 700;
    color: #ccc;
  }

  .panel-stat .tok-label {
    font-weight: 700;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: #888;
  }

  /* CodeMirror container */
  #editor-wrap {
    flex: 1;
    overflow: hidden;
    min-height: 0;
    min-width: 0;
  }

  #editor-wrap .cm-editor {
    height: 100%;
    width: 100%;
    background: transparent;
  }

  #editor-wrap .cm-editor .cm-scroller {
    font-family: "SF Mono", "Fira Code", "JetBrains Mono", Consolas, monospace;
    font-size: 13px;
    line-height: 1.6;
    padding: 12px 0;
  }

  #editor-wrap .cm-editor .cm-content {
    padding: 0 20px;
  }

  #editor-wrap .cm-editor .cm-gutters {
    display: none;
  }

  #editor-wrap .cm-editor.cm-focused {
    outline: none;
  }

  #editor-wrap .cm-editor .cm-activeLine,
  #editor-wrap .cm-editor .cm-activeLineGutter {
    background: transparent;
  }

  .output {
    flex: 1;
    width: 100%;
    padding: 12px 20px;
    background: transparent;
    font-family: "SF Mono", "Fira Code", "JetBrains Mono", Consolas, monospace;
    font-size: 13px;
    line-height: 1.6;
    border: none;
    outline: none;
    resize: none;
    tab-size: 2;
    overflow: auto;
    white-space: pre;
    color: #d4d4d4;
  }

  .output.empty { color: #333; }

  /* JSXN syntax highlighting */
  .jsxn-header { color: #c586c0; }
  .jsxn-alias-name { color: #9cdcfe; }
  .jsxn-alias-val { color: #ce9178; }
  .jsxn-tag { color: #4ec9b0; }
  .jsxn-class { color: #dcdcaa; }
  .jsxn-id { color: #d7ba7d; }
  .jsxn-string { color: #ce9178; }
  .jsxn-expr { color: #9cdcfe; }
  .jsxn-prop-brace { color: #d4d4d4; }
  .jsxn-prop-key { color: #9cdcfe; }
  .jsxn-prop-val { color: #d4d4d4; }
  .jsxn-cond { color: #c586c0; }
  .jsxn-map { color: #c586c0; }
  .jsxn-chevron { color: #666; }
  .jsxn-pipe { color: #666; }
  .jsxn-fragment { color: #c586c0; }
  .jsxn-spread { color: #569cd6; }

  /* Examples bar */
  .examples {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    border-bottom: 1px solid #1e1e1e;
    flex-shrink: 0;
    overflow-x: auto;
  }

  .examples-label {
    font-size: 11px;
    color: #555;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    white-space: nowrap;
    margin-right: 4px;
  }

  .example-btn {
    padding: 5px 14px;
    background: #1a1a1a;
    color: #999;
    border: 1px solid #2a2a2a;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 400;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
  }

  .example-btn:hover { background: #222; color: #ccc; border-color: #444; }
  .example-btn.active { background: #fff; color: #000; border-color: #fff; font-weight: 500; }

  /* Footer */
  .footer {
    border-top: 1px solid #1e1e1e;
    background: #0a0a0a;
    flex-shrink: 0;
    padding: 20px 32px;
    display: flex;
    align-items: center;
    gap: 24px;
  }

  .footer-encode {
    flex-shrink: 0;
    position: relative;
  }

  .footer-encode button {
    padding: 14px 36px;
    background: #fff;
    color: #000;
    border: none;
    border-radius: 10px;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    transition: opacity 0.15s;
  }

  .footer-encode button:hover { opacity: 0.85; }
  .footer-encode button:active { opacity: 0.7; }

  .encode-tooltip {
    position: absolute;
    bottom: calc(100% + 10px);
    left: 0;
    right: 0;
    background: #1e1e1e;
    color: #ccc;
    font-size: 12px;
    line-height: 1.4;
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid #333;
    white-space: normal;
    text-align: center;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.1s;
  }

  .encode-tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 5px solid transparent;
    border-top-color: #333;
  }

  .footer-encode:hover .encode-tooltip { opacity: 1; }

  .footer-stats {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 16px;
  }

  /* Input → Output flow */
  .stat-flow {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .stat-pill {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px 20px;
    background: #141414;
    border: 1px solid #1e1e1e;
    border-radius: 10px;
    min-width: 100px;
  }

  .stat-pill-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #555;
    margin-bottom: 4px;
  }

  .stat-pill-value {
    font-size: 22px;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    color: #ccc;
    line-height: 1;
  }

  .stat-pill-unit {
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #888;
    margin-top: 5px;
  }

  .stat-arrow {
    font-size: 18px;
    color: #333;
    flex-shrink: 0;
  }

  /* Savings hero card */
  .stat-savings {
    flex: 1;
    max-width: 360px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 12px 20px;
    background: linear-gradient(135deg, rgba(74, 222, 128, 0.06), rgba(74, 222, 128, 0.02));
    border: 1px solid rgba(74, 222, 128, 0.15);
    border-radius: 12px;
  }

  .stat-savings-top {
    display: flex;
    align-items: baseline;
    gap: 12px;
  }

  .stat-savings-pct {
    font-size: 32px;
    font-weight: 800;
    font-variant-numeric: tabular-nums;
    color: #4ade80;
    line-height: 1;
  }

  .stat-savings-detail {
    font-size: 13px;
    color: #4ade8088;
  }

  .stat-savings-detail .token-label {
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: #4ade80cc;
  }

  .stat-savings-detail span {
    font-weight: 600;
    color: #4ade80cc;
  }

  .compression-bar-track {
    height: 6px;
    background: #1a1a1a;
    border-radius: 3px;
    overflow: hidden;
  }

  .compression-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #4ade80, #22c55e);
    border-radius: 3px;
    transition: width 0.4s ease;
    width: 0%;
  }

  .banner {
    padding: 10px 20px;
    font-size: 12px;
    font-family: monospace;
    display: none;
    flex-shrink: 0;
  }

  .banner.visible { display: block; }

  .banner.error {
    background: #1a0000;
    color: #e55;
    border-top: 1px solid #300;
  }

  .banner.warning {
    background: #1a1500;
    color: #e5b750;
    border-top: 1px solid #332800;
  }

  /* Medium screens */
  @media (max-width: 1024px) {
    .footer { padding: 16px 20px; gap: 16px; }
    .stat-pill { padding: 8px 14px; min-width: 80px; }
    .stat-pill-value { font-size: 18px; }
    .stat-savings-pct { font-size: 26px; }
    .stat-savings { max-width: 280px; }
    .footer-encode button { padding: 12px 24px; font-size: 14px; }
  }

  /* Small screens: stack panels, reflow footer */
  @media (max-width: 700px) {
    body { height: auto; min-height: 100vh; overflow: auto; }
    .main { overflow: visible; min-height: 0; }
    .panels { grid-template-columns: 1fr; grid-template-rows: 300px 300px; }
    .panel { border-right: none; border-bottom: 1px solid #1e1e1e; }

    .footer {
      flex-direction: column;
      align-items: stretch;
      padding: 16px;
      gap: 12px;
    }

    .footer-encode { order: -1; }
    .footer-encode button { width: 100%; }

    .footer-stats {
      flex-direction: column;
      gap: 12px;
    }

    .stat-flow { justify-content: center; }
    .stat-savings { max-width: 100%; }
  }

  /* Very small screens */
  @media (max-width: 420px) {
    header { padding: 16px 16px 12px; }
    .examples { padding: 8px 12px; gap: 6px; }
    .example-btn { padding: 4px 10px; font-size: 11px; }
    .footer { padding: 12px; }
    .stat-pill { padding: 8px 12px; min-width: 70px; }
    .stat-pill-value { font-size: 16px; }
    .stat-savings-pct { font-size: 22px; }
  }
</style>
</head>
<body>

<header id="toolbar">
  <div style="display:flex;align-items:center">
    <h1>JSXN</h1>
    <div class="mode-toggle" role="group" aria-label="Mode">
      <button class="mode-btn active" id="mode-encode" onclick="setMode('encode')" aria-pressed="true">Encode</button>
      <button class="mode-btn" id="mode-decode" onclick="setMode('decode')" aria-pressed="false">Decode</button>
    </div>
    <div class="mode-toggle" id="format-toggle" role="group" aria-label="Format">
      <button class="mode-btn active" id="fmt-jsx" onclick="setFormat('jsx')" aria-pressed="true">JSX</button>
      <button class="mode-btn" id="fmt-html" onclick="setFormat('html')" aria-pressed="false">HTML</button>
    </div>
  </div>
  <nav aria-label="Navigation">
    <a href="index.html">&larr; Back</a>
  </nav>
</header>

<main id="main" class="main">
  <div class="examples" id="examples" role="toolbar" aria-label="Example snippets">
    <span class="examples-label">Examples</span>
  </div>
  <div class="panels" id="panels">
    <div class="panel" id="panel-input">
      <div class="panel-header">
        <label class="panel-label" id="input-label" for="editor-wrap">JSX input</label>
        <span class="panel-stat" id="input-chars"></span>
      </div>
      <div id="editor-wrap" role="textbox" aria-multiline="true" aria-labelledby="input-label"></div>
    </div>
    <div class="panel" id="panel-output">
      <div class="panel-header">
        <span class="panel-label" id="output-label">JSXN output</span>
        <span class="panel-stat" id="output-chars"></span>
      </div>
      <div class="output empty" id="output" role="region" aria-labelledby="output-label" aria-live="polite">Click "Encode" or press Cmd+Enter</div>
    </div>
  </div>

  <div class="banner warning" id="warning" role="alert"></div>
  <div class="banner error" id="error" role="alert"></div>

  <div class="footer" id="action-bar">
    <div class="footer-encode">
      <span class="encode-tooltip" id="encode-hint">Edit the input and press Cmd+Enter to run</span>
      <button id="encode-btn" aria-describedby="encode-hint">Encode</button>
    </div>
    <div class="footer-stats" id="stats" aria-live="polite">
      <div class="stat-flow">
        <div class="stat-pill">
          <span class="stat-pill-label">Input</span>
          <span class="stat-pill-value" id="stat-input-tok">—</span>
          <span class="stat-pill-unit">tokens</span>
        </div>
        <span class="stat-arrow" aria-hidden="true">→</span>
        <div class="stat-pill">
          <span class="stat-pill-label">Output</span>
          <span class="stat-pill-value" id="stat-output-tok">—</span>
          <span class="stat-pill-unit">tokens</span>
        </div>
      </div>
      <div class="stat-savings">
        <div class="stat-savings-top">
          <span class="stat-savings-pct" id="stat-pct">—</span>
          <span class="stat-savings-detail"><span id="stat-saved-tok">—</span> <span class="token-label">tokens</span> <span id="stat-saved-label">saved</span></span>
        </div>
        <div class="compression-bar-track" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Compression ratio">
          <div class="compression-bar-fill" id="compression-fill"></div>
        </div>
      </div>
    </div>
  </div>
</main>

<script type="module">
  // --- CodeMirror ---
  import { EditorView, keymap } from 'https://esm.sh/@codemirror/view@6';
  import { EditorState } from 'https://esm.sh/@codemirror/state@6';
  import { javascript } from 'https://esm.sh/@codemirror/lang-javascript@6';
  import { oneDark } from 'https://esm.sh/@codemirror/theme-one-dark@6';
  import { defaultKeymap } from 'https://esm.sh/@codemirror/commands@6';
  import { syntaxHighlighting, defaultHighlightStyle, bracketMatching } from 'https://esm.sh/@codemirror/language@6';
  import { closeBrackets } from 'https://esm.sh/@codemirror/autocomplete@6';

  // --- Babel parser ---
  import { parse } from 'https://esm.sh/@babel/parser@7.26.5';

  // --- Inline encoder (same as src/, self-contained) ---

  function parseJSX(code) {
    return parse(code, {
      sourceType: 'module',
      plugins: ['jsx', 'typescript'],
      errorRecovery: true,
    });
  }

  function analyze(ast) {
    const components = new Map();
    const props = new Map();
    const classes = new Map();
    walkForAnalysis(ast.program, components, props, classes);
    return { components, props, classes };
  }

  function walkForAnalysis(node, components, props, classes) {
    if (!node || typeof node !== 'object') return;
    if (node.type === 'JSXOpeningElement') {
      const nameNode = node.name;
      if (nameNode.type === 'JSXIdentifier' && /^[A-Z]/.test(nameNode.name)) {
        components.set(nameNode.name, (components.get(nameNode.name) ?? 0) + 1);
      }
      for (const attr of node.attributes) {
        if (attr.type === 'JSXAttribute') {
          const propName = attr.name.type === 'JSXNamespacedName'
            ? `${attr.name.namespace.name}:${attr.name.name.name}`
            : attr.name.name;
          if (propName === 'className') {
            const val = attr.value;
            if (val && val.type === 'StringLiteral') {
              for (const cls of val.value.split(/\s+/).filter(Boolean)) {
                classes.set(cls, (classes.get(cls) ?? 0) + 1);
              }
            }
            continue;
          }
          if (propName !== 'id') {
            props.set(propName, (props.get(propName) ?? 0) + 1);
          }
        }
      }
    }
    for (const key of Object.keys(node)) {
      if (key === 'loc' || key === 'leadingComments' || key === 'trailingComments') continue;
      const val = node[key];
      if (Array.isArray(val)) { for (const item of val) walkForAnalysis(item, components, props, classes); }
      else if (val && typeof val === 'object' && val.type) walkForAnalysis(val, components, props, classes);
    }
  }

  function generateAliases(frequencies) {
    return { components: genCompAliases(frequencies.components), props: genPropAliases(frequencies.props), classes: genClassAliases(frequencies.classes ?? new Map()) };
  }

  function genCompAliases(freq) {
    const aliases = new Map();
    const candidates = [...freq.entries()].filter(([n]) => n.length > 1).sort((a, b) => b[1] - a[1]);
    const used = new Set();
    for (const [name] of candidates) { const a = findAlias(name, used, true); used.add(a); aliases.set(name, a); }
    return aliases;
  }

  function genPropAliases(freq) {
    const aliases = new Map();
    const candidates = [...freq.entries()].filter(([n, c]) => c >= 2 && n.length > 4).sort((a, b) => b[1] - a[1]);
    const used = new Set();
    for (const [name] of candidates) { const a = findAlias(name, used, false); used.add(a); aliases.set(name, a); }
    return aliases;
  }

  function genClassAliases(freq) {
    const aliases = new Map();
    const candidates = [...freq.entries()].filter(([n, c]) => c >= 2 && n.length > 3)
      .sort((a, b) => (b[1] * b[0].length) - (a[1] * a[0].length));
    const used = new Set();
    for (const [name] of candidates) {
      const alias = findClassAlias(name, used);
      if (alias.length < name.length) { used.add(alias); aliases.set(name, alias); }
    }
    return aliases;
  }

  function findClassAlias(name, used) {
    const segs = name.split(/[-:]/);
    let a = segs.map(s => s[0] ?? '').join('');
    if (a && !used.has(a) && a.length < name.length) return a;
    const last = segs[segs.length - 1];
    if (last.length > 1) { a = segs.map(s => s[0] ?? '').join('') + last[last.length - 1]; if (!used.has(a) && a.length < name.length) return a; }
    if (segs[0].length >= 2) { a = segs[0].slice(0, 2) + segs.slice(1).map(s => s[0] ?? '').join(''); if (!used.has(a) && a.length < name.length) return a; }
    for (let len = 2; len < name.length; len++) { a = name.replace(/[-:]/g, '').slice(0, len); if (!used.has(a) && a.length < name.length) return a; }
    return name;
  }

  function findAlias(name, used, isComp) {
    if (!isComp && name.startsWith('on') && name.length > 2) {
      const ev = name.slice(2);
      for (let i = ev.length - 1; i >= 0; i--) { const ch = ev[i].toLowerCase(); if (!used.has(ch)) return ch; }
      for (let i = 0; i < ev.length - 1; i++) { const t = ev.slice(i, i + 2).toLowerCase(); if (!used.has(t)) return t; }
    }
    const fc = isComp ? name[0].toUpperCase() : name[0].toLowerCase();
    if (!used.has(fc)) return fc;
    let a = fc;
    for (let i = 1; i < name.length; i++) { a += isComp ? name[i] : name[i].toLowerCase(); if (!used.has(a)) return a; }
    return a;
  }

  function formatHeaders(aliases) {
    const lines = [];
    if (aliases.components.size > 0) lines.push('@C ' + [...aliases.components.entries()].map(([n, a]) => `${n}=${a}`).join(', '));
    if (aliases.props.size > 0) lines.push('@P ' + [...aliases.props.entries()].map(([n, a]) => `${n}=${a}`).join(', '));
    if (aliases.classes.size > 0) lines.push('@S ' + [...aliases.classes.entries()].map(([n, a]) => `${n}=${a}`).join(', '));
    return lines.join('\n');
  }

  function emit(ast, aliases, code) {
    const ctx = { ca: aliases?.components ?? new Map(), pa: aliases?.props ?? new Map(), sa: aliases?.classes ?? new Map(), code };
    const lines = [];
    for (const stmt of ast.program.body) collectJSX(stmt, (node) => emitNode(node, 0, lines, ctx));
    return lines.join('\n');
  }

  function ind(l) { return ' '.repeat(l); }

  function collectJSX(node, cb) {
    if (!node) return;
    if (node.type === 'JSXElement' || node.type === 'JSXFragment') { cb(node); return; }
    if (node.type === 'ExpressionStatement') collectJSX(node.expression, cb);
    else if (node.type === 'ReturnStatement') collectJSX(node.argument, cb);
    else if (node.type === 'ParenthesizedExpression') collectJSX(node.expression, cb);
    else if (node.type === 'ExportDefaultDeclaration' || node.type === 'ExportNamedDeclaration') collectJSX(node.declaration, cb);
    else if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') collectJSXBlock(node.body, cb);
    else if (node.type === 'VariableDeclaration') { for (const d of node.declarations) if (d.init) collectJSX(d.init, cb); }
  }

  function collectJSXBlock(node, cb) {
    if (!node) return;
    if (node.type === 'BlockStatement') { for (const s of node.body) collectJSX(s, cb); }
    else collectJSX(node, cb);
  }

  function getTagName(n, ca) { const raw = getRawTag(n); return ca.get(raw) ?? raw; }
  function getRawTag(n) {
    if (n.type === 'JSXIdentifier') return n.name;
    if (n.type === 'JSXMemberExpression') return `${getRawTag(n.object)}.${n.property.name}`;
    if (n.type === 'JSXNamespacedName') return `${n.namespace.name}:${n.name.name}`;
    return 'unknown';
  }

  function emitNode(node, level, lines, ctx) {
    if (node.type === 'JSXFragment') { lines.push(`${ind(level)}_`); for (const c of sigChildren(node.children)) emitNode(c, level + 1, lines, ctx); return; }
    if (node.type === 'JSXText') { const t = node.value.trim(); if (t) lines.push(`${ind(level)}"${t}"`); return; }
    if (node.type === 'JSXExpressionContainer') { emitExpr(node, level, lines, ctx); return; }
    if (node.type === 'JSXSpreadChild') { lines.push(`${ind(level)}(...${ctx.code.slice(node.argument.start, node.argument.end)})`); return; }
    if (node.type !== 'JSXElement') return;

    const op = node.openingElement;
    const tag = getTagName(op.name, ctx.ca);
    let cls = null, idv = null;
    const other = [];

    for (const attr of op.attributes) {
      if (attr.type === 'JSXSpreadAttribute') { other.push({ spread: true, node: attr }); continue; }
      const pn = attr.name.type === 'JSXNamespacedName' ? `${attr.name.namespace.name}:${attr.name.name.name}` : attr.name.name;
      if (pn === 'className') { cls = attrVal(attr, ctx.code); continue; }
      if (pn === 'id') { idv = attrVal(attr, ctx.code); continue; }
      other.push({ propName: pn, attr });
    }

    const hasSel = idv !== null || cls !== null;
    let line = (tag === 'div' && hasSel) ? '' : tag;
    if (idv) line += idv.type === 'string' ? `#${idv.value}` : `#{${idv.value}}`;
    if (cls) {
      if (cls.type === 'string') { for (const c of cls.value.split(/\s+/).filter(Boolean)) line += `.${ctx.sa.get(c) ?? c}`; }
      else line += `.{${cls.value}}`;
    }
    const ps = fmtProps(other, ctx.pa, ctx.code);
    if (ps) line += ` ${ps}`;

    const children = sigChildren(node.children);
    if (children.length === 0) { lines.push(`${ind(level)}${line}`); }
    else if (children.length === 1 && isInline(children[0])) {
      const c = children[0];
      if (c.type === 'JSXText') lines.push(`${ind(level)}${line} "${c.value.trim()}"`);
      else if (c.type === 'JSXExpressionContainer') {
        const e = c.expression;
        lines.push(`${ind(level)}${line} ${e.type === 'StringLiteral' ? `"${e.value}"` : `(${ctx.code.slice(e.start, e.end)})`}`);
      }
    } else {
      lines.push(`${ind(level)}${line}`);
      for (const c of children) emitNode(c, level + 1, lines, ctx);
    }
  }

  function emitExpr(node, level, lines, ctx) {
    const expr = node.expression;
    if (!expr || expr.type === 'JSXEmptyExpression') return;
    if (expr.type === 'LogicalExpression' && expr.operator === '&&' && isJSXN(expr.right)) {
      const cond = ctx.code.slice(expr.left.start, expr.left.end);
      const cl = []; emitNode(unwrap(expr.right), 0, cl, ctx);
      lines.push(`${ind(level)}?${cond} > ${cl[0].trim()}`);
      for (let i = 1; i < cl.length; i++) lines.push(`${ind(level)} ${cl[i]}`);
      return;
    }
    if (expr.type === 'ConditionalExpression' && (isJSXN(expr.consequent) || isJSXN(expr.alternate))) {
      const cond = ctx.code.slice(expr.test.start, expr.test.end);
      const cn = unwrap(expr.consequent), al = unwrap(expr.alternate);
      if (isJSXN(cn) && isJSXN(al)) {
        const cl = []; emitNode(cn, 0, cl, ctx);
        const al2 = []; emitNode(al, 0, al2, ctx);
        lines.push(`${ind(level)}?${cond} > ${cl[0].trim()} | ${al2[0].trim()}`);
        return;
      }
    }
    if (isMap(expr)) { emitMap(expr, level, lines, ctx); return; }
    lines.push(`${ind(level)}(${ctx.code.slice(expr.start, expr.end)})`);
  }

  function isMap(e) { return e.type === 'CallExpression' && e.callee.type === 'MemberExpression' && e.callee.property.name === 'map' && e.arguments.length >= 1; }

  function emitMap(expr, level, lines, ctx) {
    const coll = ctx.code.slice(expr.callee.object.start, expr.callee.object.end);
    const jsx = getMapJSX(expr.arguments[0]);
    if (jsx) {
      const cl = []; emitNode(jsx, 0, cl, ctx);
      lines.push(`${ind(level)}*${coll} > ${cl[0].trim()}`);
      for (let i = 1; i < cl.length; i++) lines.push(`${ind(level)} ${cl[i]}`);
    } else lines.push(`${ind(level)}(${ctx.code.slice(expr.start, expr.end)})`);
  }

  function getMapJSX(cb) {
    if (!cb) return null;
    if (cb.type === 'ArrowFunctionExpression' || cb.type === 'FunctionExpression') {
      const b = cb.body;
      if (b.type === 'JSXElement' || b.type === 'JSXFragment') return b;
      if (b.type === 'ParenthesizedExpression') { const i = b.expression; if (i.type === 'JSXElement' || i.type === 'JSXFragment') return i; }
      if (b.type === 'BlockStatement') { for (const s of b.body) { if (s.type === 'ReturnStatement' && s.argument) { const a = unwrap(s.argument); if (a.type === 'JSXElement' || a.type === 'JSXFragment') return a; } } }
    }
    return null;
  }

  function unwrap(n) { while (n && n.type === 'ParenthesizedExpression') n = n.expression; return n; }
  function isJSXN(n) { const u = unwrap(n); return u && (u.type === 'JSXElement' || u.type === 'JSXFragment'); }
  function sigChildren(children) { return children.filter(c => c.type === 'JSXText' ? c.value.trim().length > 0 : !(c.type === 'JSXExpressionContainer' && c.expression.type === 'JSXEmptyExpression')); }

  function isInline(c) {
    if (c.type === 'JSXText') return true;
    if (c.type === 'JSXExpressionContainer') {
      const e = c.expression;
      if (e.type === 'LogicalExpression' && e.operator === '&&' && isJSXN(e.right)) return false;
      if (e.type === 'ConditionalExpression' && (isJSXN(e.consequent) || isJSXN(e.alternate))) return false;
      if (isMap(e)) return false;
      if (isJSXN(e)) return false;
      return true;
    }
    return false;
  }

  function attrVal(attr, code) {
    const v = attr.value;
    if (!v) return { type: 'boolean', value: true };
    if (v.type === 'StringLiteral') return { type: 'string', value: v.value };
    if (v.type === 'JSXExpressionContainer') {
      const e = v.expression;
      if (e.type === 'StringLiteral') return { type: 'string', value: e.value };
      return { type: 'expression', value: code.slice(e.start, e.end) };
    }
    return { type: 'string', value: String(v.value ?? '') };
  }

  function fmtProps(props, pa, code) {
    if (!props.length) return '';
    const parts = [];
    for (const p of props) {
      if (p.spread) { parts.push(`...${code.slice(p.node.argument.start, p.node.argument.end)}`); continue; }
      const alias = pa.get(p.propName) ?? p.propName;
      const val = attrVal(p.attr, code);
      if (val.type === 'boolean') { parts.push(alias); continue; }
      parts.push(`${alias}:${val.value}`);
    }
    return `{${parts.join(', ')}}`;
  }

  function hasJSX(ast) {
    let found = false;
    const MAX_DEPTH = 200;
    function walk(n, depth) {
      if (found || !n || typeof n !== 'object' || depth > MAX_DEPTH) return;
      if (n.type === 'JSXElement' || n.type === 'JSXFragment') { found = true; return; }
      for (const k of Object.keys(n)) {
        if (k === 'loc' || k === 'leadingComments' || k === 'trailingComments') continue;
        const v = n[k];
        if (Array.isArray(v)) for (const i of v) walk(i, depth + 1);
        else if (v && typeof v === 'object' && v.type) walk(v, depth + 1);
        if (found) return;
      }
    }
    walk(ast.program, 0);
    return found;
  }

  function encode(code) {
    const ast = parseJSX(code);
    const errors = ast.errors ?? [];
    if (!hasJSX(ast)) return { output: code, errors };
    const freq = analyze(ast);
    const aliases = generateAliases(freq);
    const headers = formatHeaders(aliases);
    const body = emit(ast, aliases, code);
    return { output: headers ? `${headers}\n\n${body}` : body, errors };
  }

  // --- Full file encoder ---

  function encodeFile(code) {
    const ast = parseJSX(code);
    const errors = ast.errors ?? [];
    if (!hasJSX(ast)) return { output: code, errors };

    const sections = [];

    // Directives ("use client", etc.)
    for (const dir of ast.program.directives ?? []) {
      sections.push(`"${dir.value.value}"`);
    }

    const imports = [], typeImports = [], rest = [];
    for (const stmt of ast.program.body) {
      if (stmt.type === 'ImportDeclaration') {
        (stmt.importKind === 'type' ? typeImports : imports).push(stmt);
      } else {
        rest.push(stmt);
      }
    }

    for (const imp of imports) sections.push(compressImport(imp));
    for (const imp of typeImports) sections.push(compressTypeImport(imp));
    for (const stmt of rest) {
      const r = processStmt(stmt, code);
      if (r !== null) sections.push(r);
    }

    return { output: sections.join('\n'), errors };
  }

  function compressImport(node) {
    const src = node.source.value, specs = node.specifiers;
    if (!specs.length) return `@I "${src}"`;
    const parts = specs.map(s => {
      if (s.type === 'ImportDefaultSpecifier') return `default ${s.local.name}`;
      if (s.type === 'ImportNamespaceSpecifier') return `* as ${s.local.name}`;
      if (s.importKind === 'type') return `type ${s.local.name}`;
      if (s.imported.name !== s.local.name) return `${s.imported.name} as ${s.local.name}`;
      return s.local.name;
    });
    return `@I ${src}: ${parts.join(', ')}`;
  }

  function compressTypeImport(node) {
    const src = node.source.value, specs = node.specifiers;
    if (!specs.length) return `@T "${src}"`;
    const parts = specs.map(s => {
      if (s.type === 'ImportDefaultSpecifier') return `default ${s.local.name}`;
      if (s.imported.name !== s.local.name) return `${s.imported.name} as ${s.local.name}`;
      return s.local.name;
    });
    return `@T ${src}: ${parts.join(', ')}`;
  }

  function processStmt(stmt, code) {
    if (stmt.type === 'ExpressionStatement') {
      const e = stmt.expression;
      if (e.type === 'StringLiteral' || e.type === 'DirectiveLiteral') return `"${e.value}"`;
      return code.slice(stmt.start, stmt.end);
    }
    if (stmt.type === 'TSInterfaceDeclaration') {
      const body = code.slice(stmt.body.start, stmt.body.end);
      if (stmt.extends?.length) {
        const ext = stmt.extends.map(e => code.slice(e.start, e.end)).join(', ');
        return `${stmt.id.name} extends ${ext} ${body}`;
      }
      return `${stmt.id.name} ${body}`;
    }
    if (stmt.type === 'TSTypeAliasDeclaration') {
      return `${stmt.id.name} = ${code.slice(stmt.typeAnnotation.start, stmt.typeAnnotation.end)}`;
    }
    if (stmt.type === 'ExportDefaultDeclaration') {
      const d = stmt.declaration;
      if (d?.type === 'FunctionDeclaration') return processComp(d, code, 'export default ');
      if (d?.type === 'ArrowFunctionExpression' || d?.type === 'FunctionExpression') return processComp(d, code, 'export default ');
      return code.slice(stmt.start, stmt.end);
    }
    if (stmt.type === 'ExportNamedDeclaration') {
      const d = stmt.declaration;
      if (d?.type === 'FunctionDeclaration') return processComp(d, code, 'export ');
      if (d?.type === 'VariableDeclaration') return processVarDecl(d, code, 'export ');
      return code.slice(stmt.start, stmt.end);
    }
    if (stmt.type === 'FunctionDeclaration') return processComp(stmt, code, '');
    if (stmt.type === 'VariableDeclaration') return processVarDecl(stmt, code, '');
    return code.slice(stmt.start, stmt.end);
  }

  function processVarDecl(stmt, code, prefix) {
    if (stmt.declarations.length === 1) {
      const d = stmt.declarations[0];
      if (d.id.type === 'Identifier' && d.init && (d.init.type === 'ArrowFunctionExpression' || d.init.type === 'FunctionExpression')) {
        if (containsJSXNode(d.init)) return processComp(d.init, code, prefix, d.id.name);
      }
    }
    return prefix + code.slice(stmt.start, stmt.end).replace(/^(const|let|var)\s+/, '');
  }

  function containsJSXNode(node, depth = 0) {
    if (!node || typeof node !== 'object' || depth > 200) return false;
    if (node.type === 'JSXElement' || node.type === 'JSXFragment') return true;
    for (const k of Object.keys(node)) {
      if (k === 'loc' || k === 'leadingComments' || k === 'trailingComments') continue;
      const v = node[k];
      if (Array.isArray(v)) { for (const i of v) if (containsJSXNode(i, depth + 1)) return true; }
      else if (v && typeof v === 'object' && v.type && containsJSXNode(v, depth + 1)) return true;
    }
    return false;
  }

  function processComp(fn, code, prefix, forceName) {
    const body = fn.body;
    if (!body) return prefix + code.slice(fn.start, fn.end);

    if (body.type === 'JSXElement' || body.type === 'JSXFragment') {
      const sig = buildSig(fn, code, prefix, forceName);
      const jsxn = encodeJSXSlice(body, code);
      return `${sig}\n  ---\n${jsxn.split('\n').map(l => l ? '  ' + l : '').join('\n')}`;
    }

    if (body.type !== 'BlockStatement' || !containsJSXNode(fn)) {
      return prefix + code.slice(fn.start, fn.end);
    }

    const sig = buildSig(fn, code, prefix, forceName);
    const hooks = [], logic = [];
    let jsxNode = null;

    for (const s of body.body) {
      if (s.type === 'ReturnStatement') {
        jsxNode = findReturnJSX(s);
        if (!jsxNode) logic.push('  ' + code.slice(s.start, s.end));
        continue;
      }
      const h = tryHook(s, code);
      if (h !== null) { hooks.push('  ' + h); continue; }
      logic.push('  ' + code.slice(s.start, s.end).replace(/^(const|let|var)\s+/, ''));
    }

    const parts = [sig];
    if (hooks.length) parts.push(hooks.join('\n'));
    if (logic.length) { if (hooks.length) parts.push(''); parts.push(logic.join('\n')); }
    if (jsxNode) {
      parts.push('  ---');
      const jsxn = encodeJSXSlice(jsxNode, code);
      parts.push(jsxn.split('\n').map(l => l ? '  ' + l : '').join('\n'));
    }
    return parts.join('\n');
  }

  function buildSig(fn, code, prefix, forceName) {
    const name = forceName || (fn.id ? fn.id.name : '');
    const ps = fn.params.length ? '(' + fn.params.map(p => {
      if (p.typeAnnotation && p.type === 'Identifier') return p.name;
      return code.slice(p.start, p.end);
    }).join(', ') + ')' : '()';
    return `${prefix}${name}${ps}`;
  }

  function tryHook(stmt, code) {
    if (stmt.type === 'VariableDeclaration' && stmt.declarations.length === 1) {
      const d = stmt.declarations[0], init = d.init;
      if (!init || init.type !== 'CallExpression') return null;
      const cn = init.callee.type === 'Identifier' ? init.callee.name : null;
      if (!cn) return null;
      if (cn === 'useState') {
        let name;
        if (d.id.type === 'ArrayPattern' && d.id.elements.length >= 1) name = d.id.elements[0].name;
        else if (d.id.type === 'Identifier') name = d.id.name;
        else return null;
        return `@state ${name} = ${init.arguments.length ? code.slice(init.arguments[0].start, init.arguments[0].end) : 'undefined'}`;
      }
      if (cn === 'useRef') {
        const name = d.id.type === 'Identifier' ? d.id.name : code.slice(d.id.start, d.id.end);
        return `@ref ${name} = ${init.arguments.length ? code.slice(init.arguments[0].start, init.arguments[0].end) : 'undefined'}`;
      }
      if (cn.startsWith('use') && cn.length > 3) {
        const name = d.id.type === 'Identifier' ? d.id.name : code.slice(d.id.start, d.id.end);
        return `${name} = ${cn}${code.slice(init.start + cn.length, init.end)}`;
      }
    }
    if (stmt.type === 'ExpressionStatement' && stmt.expression.type === 'CallExpression') {
      const cn = stmt.expression.callee.type === 'Identifier' ? stmt.expression.callee.name : null;
      if (cn && cn.startsWith('use') && cn.length > 3) return code.slice(stmt.start, stmt.end);
    }
    return null;
  }

  function findReturnJSX(stmt) {
    if (!stmt.argument) return null;
    let n = stmt.argument;
    while (n && n.type === 'ParenthesizedExpression') n = n.expression;
    if (n.type === 'JSXElement' || n.type === 'JSXFragment') return n;
    return null;
  }

  function encodeJSXSlice(jsxNode, code) {
    const src = code.slice(jsxNode.start, jsxNode.end);
    const ast = parseJSX(src);
    const freq = analyze(ast);
    const aliases = generateAliases(freq);
    const headers = formatHeaders(aliases);
    const body = emit(ast, aliases, src);
    return headers ? `${headers}\n\n${body}` : body;
  }

  // --- Inline decoder (same as src/decoder.js + file-decoder.js, self-contained) ---

  function decodeFn(jsxn) {
    if (!jsxn || !jsxn.trim()) return '';
    const lines = jsxn.split('\n');
    const rC = new Map(), rP = new Map(), rS = new Map();
    const bodyLines = [];
    for (const line of lines) {
      if (line.startsWith('@C ')) parseAH(line.slice(3), rC);
      else if (line.startsWith('@P ')) parseAH(line.slice(3), rP);
      else if (line.startsWith('@S ')) parseAH(line.slice(3), rS);
      else bodyLines.push(line);
    }
    while (bodyLines.length && !bodyLines[0].trim()) bodyLines.shift();
    while (bodyLines.length && !bodyLines[bodyLines.length - 1].trim()) bodyLines.pop();
    if (!bodyLines.length) return '';
    const ctx = { rC, rP, rS };
    const roots = buildDecTree(bodyLines, ctx);
    const out = [];
    for (const n of roots) emitJSXDec(n, 0, out);
    return out.join('\n');
  }

  function parseAH(str, map) {
    for (const e of str.split(',')) {
      const t = e.trim(); if (!t) continue;
      const eq = t.indexOf('='); if (eq === -1) continue;
      map.set(t.slice(eq + 1).trim(), t.slice(0, eq).trim());
    }
  }

  function buildDecTree(lines, ctx) {
    const roots = [], stack = [];
    let i = 0;
    while (i < lines.length) {
      const raw = lines[i], trimmed = raw.trimStart();
      const lineIndent = raw.length - trimmed.length;
      if (!trimmed) { i++; continue; }
      const node = classifyDec(trimmed, ctx);
      node.children = node.children || [];
      while (stack.length && stack[stack.length - 1].indent >= lineIndent) stack.pop();
      if (!stack.length) roots.push(node);
      else stack[stack.length - 1].node.children.push(node);
      stack.push({ node, indent: lineIndent });
      if (node.type === 'conditional' || node.type === 'map') {
        const ic = node.child;
        if (ic && ic.type === 'element') stack.push({ node: ic, indent: lineIndent + 1 });
      }
      i++;
    }
    return roots;
  }

  function classifyDec(t, ctx) {
    if (t === '_') return { type: 'fragment' };
    if (t.startsWith('?') && t.includes('>') && t.includes('|')) return parseTernDec(t, ctx);
    if (t.startsWith('?') && t.includes('>')) return parseCondDec(t, ctx);
    if (t.startsWith('*') && t.includes('>')) return parseMapDec(t, ctx);
    if (t.startsWith('"') && t.endsWith('"')) return { type: 'text', value: t.slice(1, -1) };
    if (t.startsWith('(') && t.endsWith(')')) return { type: 'expression', value: t.slice(1, -1) };
    return parseElDec(t, ctx);
  }

  function parseTernDec(t, ctx) {
    const a = t.slice(1), gi = a.indexOf('>'), cond = a.slice(0, gi).trim(), rest = a.slice(gi + 1).trim();
    let d = 0, pi = -1;
    for (let i = 0; i < rest.length; i++) {
      if ('{(['.includes(rest[i])) d++; else if ('})]'.includes(rest[i])) d--;
      if (rest[i] === '|' && d === 0) { pi = i; break; }
    }
    const cons = classifyDec(rest.slice(0, pi).trim(), ctx); cons.children = cons.children || [];
    const alt = classifyDec(rest.slice(pi + 1).trim(), ctx); alt.children = alt.children || [];
    return { type: 'ternary', condition: cond, consequent: cons, alternate: alt };
  }

  function parseCondDec(t, ctx) {
    const a = t.slice(1), gi = a.indexOf('>');
    const child = classifyDec(a.slice(gi + 1).trim(), ctx); child.children = child.children || [];
    return { type: 'conditional', condition: a.slice(0, gi).trim(), child };
  }

  function parseMapDec(t, ctx) {
    const a = t.slice(1), gi = a.indexOf('>');
    const coll = a.slice(0, gi).trim();
    const child = classifyDec(a.slice(gi + 1).trim(), ctx); child.children = child.children || [];
    const nm = coll.includes('.') ? coll.split('.').pop() : coll;
    let param;
    if (nm.endsWith('ies')) param = nm.slice(0, -3) + 'y';
    else if (nm.endsWith('ses') || nm.endsWith('xes') || nm.endsWith('zes')) param = nm.slice(0, -2);
    else if (nm.endsWith('ren') && nm.length > 4) param = nm.slice(0, -3);
    else if (nm.endsWith('s') && !nm.endsWith('ss')) param = nm.slice(0, -1);
    else param = 'item';
    return { type: 'map', collection: coll, param, child };
  }

  const STR_PROPS = new Set(['type','placeholder','href','src','alt','name','role','target','rel','method','action','htmlFor','autoComplete','d','viewBox','transform','points','fill','stroke','xmlns','preserveAspectRatio','stroke-width','stroke-linecap','stroke-linejoin','stroke-dasharray','font-family','font-size','font-weight','text-anchor','opacity','rx','ry','cx','cy','r','x','y','x1','y1','x2','y2','width','height','dx','dy','offset','stop-color','stop-opacity']);

  function parseElDec(t, ctx) {
    let pos = 0, tag = '', id = null, classes = [], props = [], inlineChild = null;
    if (t[0] === '.' || t[0] === '#') { tag = 'div'; }
    else {
      while (pos < t.length && t[pos] !== '#' && t[pos] !== ' ' && t[pos] !== '{') {
        if (t[pos] === '.') { if (pos + 1 < t.length && /[A-Z]/.test(t[pos + 1])) { pos++; continue; } break; }
        pos++;
      }
      tag = t.slice(0, pos);
    }
    tag = ctx.rC.get(tag) || tag;
    const isME = tag.includes('.');
    if (!isME) {
      while (pos < t.length && (t[pos] === '.' || t[pos] === '#')) {
        if (t[pos] === '#') {
          pos++;
          if (t[pos] === '{') { pos++; const e = fbb(t, pos - 1); id = { type: 'expression', value: t.slice(pos, e) }; pos = e + 1; }
          else { const s = pos; while (pos < t.length && !'.# {'.includes(t[pos])) pos++; id = { type: 'string', value: t.slice(s, pos) }; }
        } else {
          pos++;
          if (t[pos] === '{') { pos++; const e = fbb(t, pos - 1); classes.push({ type: 'expression', value: t.slice(pos, e) }); pos = e + 1; }
          else { const s = pos; while (pos < t.length && !'.# {'.includes(t[pos])) pos++; classes.push({ type: 'string', value: ctx.rS.get(t.slice(s, pos)) || t.slice(s, pos) }); }
        }
      }
    }
    while (pos < t.length && t[pos] === ' ') pos++;
    if (pos < t.length && t[pos] === '{') {
      const e = fbb(t, pos), block = t.slice(pos + 1, e);
      if (looksLikeP(block)) { parsePB(block, props, ctx); pos = e + 1; while (pos < t.length && t[pos] === ' ') pos++; }
    }
    if (pos < t.length) {
      const rest = t.slice(pos);
      if (rest.startsWith('"') && rest.endsWith('"')) inlineChild = { type: 'text', value: rest.slice(1, -1) };
      else if (rest.startsWith('(') && rest.endsWith(')')) inlineChild = { type: 'expression', value: rest.slice(1, -1) };
    }
    return { type: 'element', tag, id, classes, props, inlineChild, children: [] };
  }

  function looksLikeP(b) { if (b.startsWith('...')) return true; return /^[a-zA-Z_$]/.test(b.trim()); }

  function parsePB(block, props, ctx) {
    const parts = splitP(block);
    for (const part of parts) {
      const t = part.trim(); if (!t) continue;
      if (t.startsWith('...')) { props.push({ type: 'spread', value: t.slice(3) }); continue; }
      const ci = t.indexOf(':');
      if (ci === -1) { props.push({ type: 'boolean', name: ctx.rP.get(t) || t }); continue; }
      const key = t.slice(0, ci); let val = t.slice(ci + 1);
      if (val.startsWith('"') && val.endsWith('"')) val = val.slice(1, -1);
      const name = ctx.rP.get(key) || key;
      if (STR_PROPS.has(name) && isSSV(val)) props.push({ type: 'string', name, value: val });
      else props.push({ type: 'expression', name, value: val });
    }
  }

  function splitP(b) {
    const p = []; let d = 0, s = 0, q = false;
    for (let i = 0; i < b.length; i++) {
      if (b[i] === '"' && d === 0) { q = !q; }
      else if (!q) { if ('{(['.includes(b[i])) d++; else if ('})]'.includes(b[i])) d--; else if (b[i] === ',' && d === 0) { p.push(b.slice(s, i)); s = i + 1; } }
    }
    p.push(b.slice(s)); return p;
  }

  function isSSV(v) {
    if (/[{}()=>!&|?+\[\]]/.test(v)) return false;
    if (v.includes(' ')) return true;
    if (v.startsWith('#')) return true;
    if (/[.\-\/]/.test(v)) return true;
    if (/^[0-9]/.test(v)) return true;
    if (/^(currentColor|evenOdd|nonZero|sRGB|linearRGB)$/.test(v)) return true;
    if (/^[a-zA-Z0-9_]+$/.test(v) && !/[a-z][A-Z]/.test(v)) return true;
    return false;
  }

  function fbb(s, o) { let d = 0; for (let i = o; i < s.length; i++) { if (s[i] === '{') d++; else if (s[i] === '}') { d--; if (d === 0) return i; } } return s.length - 1; }

  function emitJSXDec(node, level, out) {
    const ind = '  '.repeat(level);
    switch (node.type) {
      case 'fragment': out.push(`${ind}<>`); for (const c of node.children) emitJSXDec(c, level + 1, out); out.push(`${ind}</>`); break;
      case 'text': out.push(`${ind}${node.value}`); break;
      case 'expression': out.push(`${ind}{${node.value}}`); break;
      case 'conditional': emitCondDec(node, level, out); break;
      case 'ternary': emitTernDec(node, level, out); break;
      case 'map': emitMapDec(node, level, out); break;
      case 'element': emitElDec(node, level, out); break;
    }
  }

  function emitElDec(node, level, out) {
    const ind = '  '.repeat(level);
    const { tag, id, classes, props, inlineChild, children } = node;
    let op = [tag];
    if (id) op.push(id.type === 'string' ? ` id="${id.value}"` : ` id={${id.value}}`);
    if (classes.length) {
      const hasE = classes.some(c => c.type === 'expression');
      if (hasE && classes.length === 1) op.push(` className={${classes[0].value}}`);
      else if (hasE) op.push(` className={${classes.map(c => c.type === 'string' ? `"${c.value}"` : c.value).join(' + " " + ')}}`);
      else op.push(` className="${classes.map(c => c.value).join(' ')}"`);
    }
    for (const p of props) {
      if (p.type === 'spread') op.push(` {...${p.value}}`);
      else if (p.type === 'boolean') op.push(` ${p.name}`);
      else if (p.type === 'string') op.push(` ${p.name}="${p.value}"`);
      else op.push(` ${p.name}={${p.value}}`);
    }
    const otag = op.join('');
    if (!children.length && !inlineChild) { out.push(`${ind}<${otag} />`); return; }
    if (!children.length && inlineChild) {
      out.push(inlineChild.type === 'text' ? `${ind}<${otag}>${inlineChild.value}</${tag}>` : `${ind}<${otag}>{${inlineChild.value}}</${tag}>`);
      return;
    }
    out.push(`${ind}<${otag}>`);
    if (inlineChild) out.push(inlineChild.type === 'text' ? `${'  '.repeat(level + 1)}${inlineChild.value}` : `${'  '.repeat(level + 1)}{${inlineChild.value}}`);
    for (const c of children) emitJSXDec(c, level + 1, out);
    out.push(`${ind}</${tag}>`);
  }

  function emitCondDec(node, level, out) {
    const ind = '  '.repeat(level); const cl = []; emitJSXDec(node.child, 0, cl);
    if (cl.length === 1) out.push(`${ind}{${node.condition} && (${cl[0].trim()})}`);
    else { out.push(`${ind}{${node.condition} && (`); for (const l of cl) out.push(`${ind}  ${l.trimStart()}`); out.push(`${ind})}`); }
  }

  function emitTernDec(node, level, out) {
    const ind = '  '.repeat(level); const cl = []; emitJSXDec(node.consequent, 0, cl); const al = []; emitJSXDec(node.alternate, 0, al);
    if (cl.length === 1 && al.length === 1) out.push(`${ind}{${node.condition} ? (${cl[0].trim()}) : (${al[0].trim()})}`);
    else { out.push(`${ind}{${node.condition} ? (`); for (const l of cl) out.push(`${ind}  ${l.trimStart()}`); out.push(`${ind}) : (`); for (const l of al) out.push(`${ind}  ${l.trimStart()}`); out.push(`${ind})}`); }
  }

  function emitMapDec(node, level, out) {
    const ind = '  '.repeat(level); const cl = []; emitJSXDec(node.child, 0, cl);
    if (cl.length === 1) out.push(`${ind}{${node.collection}.map(${node.param} => (${cl[0].trim()}))}`);
    else { out.push(`${ind}{${node.collection}.map(${node.param} => (`); for (const l of cl) out.push(`${ind}  ${l.trimStart()}`); out.push(`${ind}))}`); }
  }

  // --- Inline file decoder ---

  function decodeFileFn(jsxn) {
    if (!jsxn || !jsxn.trim()) return '';
    const lines = jsxn.split('\n'); const output = []; let i = 0;
    while (i < lines.length) {
      const line = lines[i], t = line.trim();
      if (!t) { output.push(''); i++; continue; }
      if (t.startsWith('"use ')) { output.push(t); i++; continue; }
      if (t.startsWith('@I ')) { output.push(decImp(t)); i++; continue; }
      if (t.startsWith('@T ')) { output.push(decTImp(t)); i++; continue; }
      if (/^[A-Z]/.test(t) && !t.includes('(') && t.includes('{')) { const r = decIface(lines, i); output.push(r.text); i = r.nextIdx; continue; }
      if (/^(export\s+)?[A-Z]/.test(t) && t.includes('=') && !t.includes('(')) { output.push(decTAlias(t)); i++; continue; }
      if (/^(export\s+(default\s+)?)?[A-Za-z_$][A-Za-z0-9_$]*\(/.test(t)) { const r = decFnBlock(lines, i); output.push(r.text); i = r.nextIdx; continue; }
      output.push(line); i++;
    }
    return output.join('\n');
  }

  function decImp(line) {
    const c = line.slice(3);
    if (c.startsWith('"')) return `import ${c}`;
    const ci = c.indexOf(':'); if (ci === -1) return `import ${c}`;
    const mod = c.slice(0, ci).trim(), specStr = c.slice(ci + 1).trim();
    const specs = specStr.split(',').map(s => s.trim()).filter(Boolean);
    let def = null, ns = null; const parts = [];
    for (const s of specs) { if (s.startsWith('default ')) def = s.slice(8); else if (s.startsWith('* as ')) ns = s; else parts.push(s); }
    if (ns) return def ? `import ${def}, ${ns} from "${mod}"` : `import ${ns} from "${mod}"`;
    if (def && parts.length) return `import ${def}, { ${parts.join(', ')} } from "${mod}"`;
    if (def) return `import ${def} from "${mod}"`;
    if (parts.length) return `import { ${parts.join(', ')} } from "${mod}"`;
    return `import "${mod}"`;
  }

  function decTImp(line) {
    const c = line.slice(3);
    if (c.startsWith('"')) return `import type ${c}`;
    const ci = c.indexOf(':'); if (ci === -1) return `import type ${c}`;
    const mod = c.slice(0, ci).trim(), specStr = c.slice(ci + 1).trim();
    const specs = specStr.split(',').map(s => s.trim()).filter(Boolean);
    let def = null; const parts = [];
    for (const s of specs) { if (s.startsWith('default ')) def = s.slice(8); else parts.push(s); }
    if (def && parts.length) return `import type ${def}, { ${parts.join(', ')} } from "${mod}"`;
    if (def) return `import type ${def} from "${mod}"`;
    return `import type { ${parts.join(', ')} } from "${mod}"`;
  }

  function decIface(lines, si) {
    const fl = lines[si].trim(); let pfx = '';
    let rest = fl; if (rest.startsWith('export ')) { pfx = 'export '; rest = rest.slice(7); }
    const nm = rest.match(/^(\w+)\s*(\{.*)$/);
    if (nm) { const r = collectBraced(lines, si, nm[2]); return { text: `${pfx}interface ${nm[1]} ${r.fullBody}`, nextIdx: r.nextIdx }; }
    return { text: `${pfx}${rest}`, nextIdx: si + 1 };
  }

  function collectBraced(lines, si, first) {
    let d = 0; for (const ch of first) { if (ch === '{') d++; else if (ch === '}') d--; }
    if (d <= 0) return { fullBody: first, nextIdx: si + 1 };
    const parts = [first]; let idx = si + 1;
    while (idx < lines.length && d > 0) { for (const ch of lines[idx]) { if (ch === '{') d++; else if (ch === '}') d--; } parts.push(lines[idx]); idx++; }
    return { fullBody: parts.join('\n'), nextIdx: idx };
  }

  function decTAlias(line) {
    let pfx = '', rest = line.trim();
    if (rest.startsWith('export ')) { pfx = 'export '; rest = rest.slice(7); }
    return `${pfx}type ${rest}`;
  }

  function decFnBlock(lines, si) {
    const sig = lines[si].trim();
    const m = sig.match(/^((?:export\s+(?:default\s+)?)?)?([A-Za-z_$][A-Za-z0-9_$]*)\((.*)$/);
    if (!m) return { text: sig, nextIdx: si + 1 };
    const pfx = (m[1] || '').trim(), name = m[2], pr = m[3], pe = pr.lastIndexOf(')'), params = pe >= 0 ? pr.slice(0, pe) : pr;
    const bodyLines = []; let i = si + 1;
    while (i < lines.length) {
      const line = lines[i];
      if (line.trim() === '' && i + 1 < lines.length && /^\S/.test(lines[i + 1])) break;
      if (line.trim() === '') { bodyLines.push(''); i++; continue; }
      if (/^\s/.test(line)) { bodyLines.push(line); i++; } else break;
    }
    const hooks = [], logic = []; let jsxnLines = null, inJSX = false;
    for (const bl of bodyLines) {
      const t = bl.trim();
      if (t === '---') { inJSX = true; jsxnLines = []; continue; }
      if (inJSX) { jsxnLines.push(bl.replace(/^  /, '')); continue; }
      if (!t) continue;
      if (t.startsWith('@state ')) { const mt = t.match(/^@state\s+(\w+)\s*=\s*(.+)$/); if (mt) { const s = 'set' + mt[1][0].toUpperCase() + mt[1].slice(1); hooks.push(`  const [${mt[1]}, ${s}] = useState(${mt[2]})`); } continue; }
      if (t.startsWith('@ref ')) { const mt = t.match(/^@ref\s+(\w+)\s*=\s*(.+)$/); if (mt) hooks.push(`  const ${mt[1]} = useRef(${mt[2]})`); continue; }
      if (/^[a-zA-Z_$]/.test(t) && /= use[A-Z]/.test(t)) { hooks.push(`  const ${t}`); continue; }
      if (/^use[A-Z]/.test(t)) { hooks.push(`  ${t}`); continue; }
      if (/^(let|var)\s+/.test(t)) logic.push(`  ${t}`);
      else logic.push(`  const ${t}`);
    }
    const fp = pfx ? `${pfx} ` : '';
    const out = [`${fp}function ${name}(${params}) {`];
    for (const h of hooks) out.push(h);
    if (hooks.length && logic.length) out.push('');
    for (const l of logic) out.push(l);
    if (jsxnLines !== null) {
      if (hooks.length || logic.length) out.push('');
      const jsx = decodeFn(jsxnLines.join('\n'));
      out.push('  return (');
      for (const l of jsx.split('\n')) out.push(l ? `    ${l}` : '');
      out.push('  )');
    }
    out.push('}');
    return { text: out.join('\n'), nextIdx: i };
  }

  // --- Inline HTML parser + encoder ---

  const VOID_ELS = new Set(['area','base','br','col','embed','hr','img','input','link','meta','param','source','track','wbr']);
  const RAW_ELS = new Set(['script','style']);

  function parseHTMLInline(html) {
    let pos = 0, doctype = null;
    const roots = [], stack = [];
    function cur() { return stack.length ? stack[stack.length - 1] : null; }
    function add(n) { const p = cur(); if (p) p.children.push(n); else roots.push(n); }

    while (pos < html.length) {
      if (html[pos] === '<') {
        if (html.startsWith('<!--', pos)) { const e = html.indexOf('-->', pos + 4); pos = e < 0 ? html.length : e + 3; continue; }
        if (/^<!doctype\s/i.test(html.slice(pos, pos + 11))) { const e = html.indexOf('>', pos); if (e >= 0) { doctype = html.slice(pos + 2, e).trim(); pos = e + 1; } else pos = html.length; continue; }
        if (pos + 1 < html.length && html[pos + 1] === '/') {
          const e = html.indexOf('>', pos + 2); if (e < 0) { pos = html.length; continue; }
          const ct = html.slice(pos + 2, e).trim().toLowerCase(); pos = e + 1;
          for (let i = stack.length - 1; i >= 0; i--) { if (stack[i].tag === ct) { stack.length = i; break; } }
          continue;
        }
        pos++;
        const ts = pos; while (pos < html.length && !/[\s/>]/.test(html[pos])) pos++;
        const tag = html.slice(ts, pos).toLowerCase(); if (!tag) continue;
        const attrs = [];
        while (pos < html.length) {
          while (pos < html.length && /\s/.test(html[pos])) pos++;
          if (pos >= html.length || html[pos] === '>' || html[pos] === '/') break;
          const ns = pos; while (pos < html.length && !/[\s=/>]/.test(html[pos])) pos++; const nm = html.slice(ns, pos); if (!nm) { pos++; continue; }
          while (pos < html.length && /\s/.test(html[pos])) pos++;
          if (pos < html.length && html[pos] === '=') {
            pos++; while (pos < html.length && /\s/.test(html[pos])) pos++;
            let v = '';
            if (pos < html.length && (html[pos] === '"' || html[pos] === "'")) { const q = html[pos]; pos++; const vs = pos; while (pos < html.length && html[pos] !== q) pos++; v = html.slice(vs, pos); if (pos < html.length) pos++; }
            else { const vs = pos; while (pos < html.length && !/[\s>]/.test(html[pos])) pos++; v = html.slice(vs, pos); }
            attrs.push({ name: nm, value: v });
          } else { attrs.push({ name: nm, value: null }); }
        }
        const sc = pos < html.length && html[pos] === '/'; if (sc) pos++;
        if (pos < html.length && html[pos] === '>') pos++;
        const node = { tag, attrs, children: [] }; const isV = VOID_ELS.has(tag);
        add(node);
        if (!isV && !sc) stack.push(node);
        if (RAW_ELS.has(tag) && !sc && !isV) {
          const re = new RegExp(`</${tag}\\s*>`, 'i'), m = re.exec(html.slice(pos));
          if (m) { const rc = html.slice(pos, pos + m.index); if (rc.trim()) node.children.push({ text: rc }); pos = pos + m.index + m[0].length; if (stack.length && stack[stack.length - 1] === node) stack.pop(); }
        }
      } else {
        const ts = pos; while (pos < html.length && html[pos] !== '<') pos++;
        const t = html.slice(ts, pos).replace(/\s+/g, ' ').trim();
        if (t) add({ text: t });
      }
    }
    return { doctype, roots };
  }

  function emitHTMLNode(node, level, lines, pa, sa) {
    if (node.text !== undefined) { const t = node.text.trim(); if (t) lines.push(`${ind(level)}"${t}"`); return; }
    const { tag, attrs, children } = node;
    let cls = null, idv = null; const other = [];
    for (const a of attrs) { if (a.name === 'class') { cls = a.value || ''; continue; } if (a.name === 'id') { idv = a.value || ''; continue; } other.push(a); }
    const hasSel = idv !== null || cls !== null;
    let line = (tag === 'div' && hasSel) ? '' : tag;
    if (idv !== null) line += `#${idv}`;
    if (cls !== null) { for (const c of cls.split(/\s+/).filter(Boolean)) line += `.${sa.get(c) ?? c}`; }
    if (other.length) {
      const parts = other.map(a => { const al = pa.get(a.name) ?? a.name; if (a.value === null) return al; return a.value.includes(',') ? `${al}:"${a.value}"` : `${al}:${a.value}`; });
      line += ` {${parts.join(', ')}}`;
    }
    const sig = children.filter(c => c.text !== undefined ? c.text.trim().length > 0 : true);
    if (!sig.length) { lines.push(`${ind(level)}${line}`); }
    else if (sig.length === 1 && sig[0].text !== undefined) { lines.push(`${ind(level)}${line} "${sig[0].text.trim()}"`); }
    else { lines.push(`${ind(level)}${line}`); for (const c of sig) emitHTMLNode(c, level + 1, lines, pa, sa); }
  }

  function analyzeHTMLTree(roots) {
    const props = new Map(), classes = new Map();
    function walk(nodes) {
      for (const n of nodes) {
        if (n.text !== undefined) continue;
        for (const a of n.attrs) {
          if (a.name === 'class' && a.value) { for (const c of a.value.split(/\s+/).filter(Boolean)) classes.set(c, (classes.get(c) ?? 0) + 1); continue; }
          if (a.name === 'id') continue;
          props.set(a.name, (props.get(a.name) ?? 0) + 1);
        }
        if (n.children) walk(n.children);
      }
    }
    walk(roots);
    return { components: new Map(), props, classes };
  }

  function encodeHTMLInline(html) {
    const { doctype, roots } = parseHTMLInline(html);
    const freq = analyzeHTMLTree(roots);
    const aliases = generateAliases(freq);
    const headers = formatHeaders(aliases);
    const lines = [];
    for (const r of roots) emitHTMLNode(r, 0, lines, aliases.props, aliases.classes);
    const body = lines.join('\n');
    const parts = [];
    if (doctype) parts.push(`!${doctype}`);
    if (headers) parts.push(headers);
    if (parts.length && body) parts.push('');
    parts.push(body);
    return { output: parts.join('\n'), errors: [] };
  }

  // --- Inline HTML decoder ---

  const HTML_VOID = new Set(['area','base','br','col','embed','hr','img','input','link','meta','param','source','track','wbr']);
  const SVG_SC = new Set(['circle','ellipse','line','path','polygon','polyline','rect','stop','use','image','animate','animateMotion','animateTransform','set']);

  function decodeHTMLFn(jsxn) {
    if (!jsxn || !jsxn.trim()) return '';
    const lines = jsxn.split('\n');
    const rC = new Map(), rP = new Map(), rS = new Map();
    const bodyLines = [];
    let hasDoctype = false;
    for (const line of lines) {
      if (line.startsWith('@C ')) parseAH(line.slice(3), rC);
      else if (line.startsWith('@P ')) parseAH(line.slice(3), rP);
      else if (line.startsWith('@S ')) parseAH(line.slice(3), rS);
      else if (line.trim().startsWith('!DOCTYPE') || line.trim().startsWith('!doctype')) hasDoctype = true;
      else bodyLines.push(line);
    }
    while (bodyLines.length && !bodyLines[0].trim()) bodyLines.shift();
    while (bodyLines.length && !bodyLines[bodyLines.length - 1].trim()) bodyLines.pop();
    if (!bodyLines.length) return hasDoctype ? '<!DOCTYPE html>' : '';
    const ctx = { rC, rP, rS };
    const roots = buildDecTree(bodyLines, ctx);
    const out = [];
    if (hasDoctype) out.push('<!DOCTYPE html>');
    for (const n of roots) emitHTMLDecNode(n, 0, out);
    return out.join('\n');
  }

  function emitHTMLDecNode(node, level, out) {
    const i = '  '.repeat(level);
    switch (node.type) {
      case 'fragment': for (const c of node.children) emitHTMLDecNode(c, level, out); break;
      case 'text': out.push(`${i}${node.value}`); break;
      case 'expression': out.push(`${i}<!-- JSXN expression: ${node.value} -->`); break;
      case 'conditional': out.push(`${i}<!-- JSXN conditional: ${node.condition} -->`); emitHTMLDecNode(node.child, level, out); break;
      case 'ternary': out.push(`${i}<!-- JSXN ternary: ${node.condition} -->`); emitHTMLDecNode(node.consequent, level, out); break;
      case 'map': out.push(`${i}<!-- JSXN map: ${node.collection} -->`); emitHTMLDecNode(node.child, level, out); break;
      case 'element': emitHTMLDecEl(node, level, out); break;
    }
  }

  function emitHTMLDecEl(node, level, out) {
    const i = '  '.repeat(level);
    const { tag, id, classes, props, inlineChild, children } = node;
    const isVoid = HTML_VOID.has(tag);
    let op = [tag];
    if (id) op.push(` id="${id.value}"`);
    if (classes.length) op.push(` class="${classes.map(c => c.value).join(' ')}"`);
    for (const p of props) {
      if (p.type === 'spread') continue;
      else if (p.type === 'boolean') op.push(` ${p.name}`);
      else op.push(` ${p.name}="${p.value}"`);
    }
    const otag = op.join('');
    if (isVoid) { out.push(`${i}<${otag}>`); return; }
    if (!children.length && !inlineChild) { if (SVG_SC.has(tag)) out.push(`${i}<${otag} />`); else out.push(`${i}<${otag}></${tag}>`); return; }
    if (!children.length && inlineChild) { out.push(`${i}<${otag}>${inlineChild.value}</${tag}>`); return; }
    out.push(`${i}<${otag}>`);
    if (inlineChild) out.push(`${'  '.repeat(level + 1)}${inlineChild.value}`);
    for (const c of children) emitHTMLDecNode(c, level + 1, out);
    out.push(`${i}</${tag}>`);
  }

  // --- Token estimation ---
  // Approximate token count (~4 chars/token, standard LLM heuristic)
  function estimateTokens(text) {
    if (!text) return 0;
    return Math.ceil(text.length / 4);
  }

  // --- JSXN syntax highlighter ---

  function esc(s) {
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function highlightJSXN(text) {
    return text.split('\n').map(highlightLine).join('\n');
  }

  function highlightJSXLine(line) {
    if (!line.trim()) return '';
    let r = esc(line);
    r = r.replace(/"[^"]*"/g, '<span class="jsxn-string">$&</span>');
    r = r.replace(/(&lt;\/?)([\w.]+)/g, (_, b, t) => `${b}<span class="jsxn-tag">${t}</span>`);
    r = r.replace(/(\/?&gt;)/g, '<span class="jsxn-tag">$1</span>');
    r = r.replace(/\b(import|from|export|default|function|const|let|var|return|type|interface)\b/g, '<span class="jsxn-header">$1</span>');
    r = r.replace(/\b([a-zA-Z][\w]*)(?==(?:&quot;|<span|{|\())/g, '<span class="jsxn-prop-key">$1</span>');
    return r;
  }

  function highlightLine(line) {
    // Alias header lines: @C, @P, @S
    if (/^\s*@[CPS]\s/.test(line)) {
      return line.replace(/^(\s*@[CPS])\s(.*)$/, (_, prefix, rest) => {
        const pairs = rest.replace(/([A-Za-z][A-Za-z0-9.\-]*)=([A-Za-z][A-Za-z0-9]*)/g,
          (__, name, alias) => `<span class="jsxn-alias-name">${esc(name)}</span>=<span class="jsxn-alias-val">${esc(alias)}</span>`
        );
        return `<span class="jsxn-header">${esc(prefix)}</span> ${pairs}`;
      });
    }

    // Import lines: @I pkg: A, B, C
    if (/^\s*@[IT]\s/.test(line)) {
      return line.replace(/^(\s*@[IT])\s(.*)$/, (_, prefix, rest) => {
        return `<span class="jsxn-header">${esc(prefix)}</span> ${esc(rest)}`;
      });
    }

    // Hook shorthand: @state, @ref
    if (/^\s*@(state|ref)\s/.test(line)) {
      return line.replace(/^(\s*)(@(?:state|ref))\s(.*)$/, (_, ws, keyword, rest) => {
        return `${ws}<span class="jsxn-header">${esc(keyword)}</span> ${esc(rest)}`;
      });
    }

    // Separator: ---
    if (/^\s*---\s*$/.test(line)) {
      const ws = line.match(/^(\s*)/)[1];
      return `${ws}<span class="jsxn-header">---</span>`;
    }

    // Empty / whitespace-only
    if (!line.trim()) return '';

    const indent = line.match(/^(\s*)/)[1];
    const content = line.slice(indent.length);

    // Fragment _
    if (content === '_') {
      return `${indent}<span class="jsxn-fragment">_</span>`;
    }

    // Conditional: ?cond > ...
    if (content.startsWith('?')) {
      const m = content.match(/^\?(.+?)\s*>\s*(.*)$/);
      if (m) {
        const afterChevron = m[2];
        const pipeIdx = findTopLevelPipe(afterChevron);
        if (pipeIdx >= 0) {
          const left = afterChevron.slice(0, pipeIdx).trim();
          const right = afterChevron.slice(pipeIdx + 1).trim();
          return `${indent}<span class="jsxn-cond">?</span><span class="jsxn-expr">${esc(m[1])}</span> <span class="jsxn-chevron">&gt;</span> ${highlightTagPart(left)} <span class="jsxn-pipe">|</span> ${highlightTagPart(right)}`;
        }
        return `${indent}<span class="jsxn-cond">?</span><span class="jsxn-expr">${esc(m[1])}</span> <span class="jsxn-chevron">&gt;</span> ${highlightTagPart(afterChevron)}`;
      }
    }

    // Map: *collection > ...
    if (content.startsWith('*')) {
      const m = content.match(/^\*(.+?)\s*>\s*(.*)$/);
      if (m) {
        return `${indent}<span class="jsxn-map">*</span><span class="jsxn-expr">${esc(m[1])}</span> <span class="jsxn-chevron">&gt;</span> ${highlightTagPart(m[2])}`;
      }
    }

    // Pure string line: "text"
    if (/^".*"$/.test(content)) {
      return `${indent}<span class="jsxn-string">${esc(content)}</span>`;
    }

    // Pure expression line: (expr)
    if (content.startsWith('(') && content.endsWith(')')) {
      return `${indent}<span class="jsxn-expr">${esc(content)}</span>`;
    }

    // Tag line: tag#id.class.class {props} "text" or (expr)
    return indent + highlightTagPart(content);
  }

  function highlightTagPart(s) {
    // Break into: tagWithSelectors + optional props + optional trailing string/expr
    let rest = s;
    let result = '';

    // 1. Extract tag + #id + .classes (everything before first space or {)
    const selectorEnd = rest.search(/[\s{]/);
    const selectorPart = selectorEnd === -1 ? rest : rest.slice(0, selectorEnd);
    rest = selectorEnd === -1 ? '' : rest.slice(selectorEnd);

    // Highlight selector: tag#id.class1.class2
    result += highlightSelector(selectorPart);

    if (!rest) return result;

    // 2. If starts with space then {, it's props
    const trimmed = rest;
    const braceStart = trimmed.indexOf('{');

    if (braceStart >= 0) {
      // Everything before the brace is whitespace
      result += esc(trimmed.slice(0, braceStart));
      // Find matching close brace
      const braceEnd = findMatchingBrace(trimmed, braceStart);
      if (braceEnd >= 0) {
        const propsBlock = trimmed.slice(braceStart, braceEnd + 1);
        result += highlightProps(propsBlock);
        rest = trimmed.slice(braceEnd + 1);
      } else {
        result += esc(trimmed.slice(braceStart));
        rest = '';
      }
    } else {
      rest = trimmed;
    }

    // 3. Trailing string "..." or expression (...)
    if (rest.trim()) {
      const tr = rest.trimStart();
      const space = rest.slice(0, rest.length - tr.length);
      if (tr.startsWith('"')) {
        result += `${esc(space)}<span class="jsxn-string">${esc(tr)}</span>`;
      } else if (tr.startsWith('(')) {
        result += `${esc(space)}<span class="jsxn-expr">${esc(tr)}</span>`;
      } else {
        result += esc(rest);
      }
    }

    return result;
  }

  function highlightSelector(s) {
    // Split on # and . keeping delimiters
    const tokens = s.split(/(?=[#.])/);
    let out = '';
    for (let i = 0; i < tokens.length; i++) {
      const tok = tokens[i];
      if (tok.startsWith('#')) {
        out += `<span class="jsxn-id">${esc(tok)}</span>`;
      } else if (tok.startsWith('.')) {
        out += `<span class="jsxn-class">${esc(tok)}</span>`;
      } else {
        out += `<span class="jsxn-tag">${esc(tok)}</span>`;
      }
    }
    return out;
  }

  function highlightProps(block) {
    // {key:val, key:val, ...spread}
    const inner = block.slice(1, -1);
    let result = '<span class="jsxn-prop-brace">{</span>';

    // Split by top-level commas
    const parts = splitTopLevel(inner, ',');
    for (let i = 0; i < parts.length; i++) {
      if (i > 0) result += '<span class="jsxn-prop-brace">, </span>';
      const part = parts[i].trim();
      if (part.startsWith('...')) {
        result += `<span class="jsxn-spread">${esc(part)}</span>`;
      } else {
        const colonIdx = part.indexOf(':');
        if (colonIdx >= 0) {
          const key = part.slice(0, colonIdx);
          const val = part.slice(colonIdx + 1);
          result += `<span class="jsxn-prop-key">${esc(key)}</span>:<span class="jsxn-prop-val">${esc(val)}</span>`;
        } else {
          // Boolean prop
          result += `<span class="jsxn-prop-key">${esc(part)}</span>`;
        }
      }
    }

    result += '<span class="jsxn-prop-brace">}</span>';
    return result;
  }

  function findMatchingBrace(s, start) {
    let depth = 0;
    for (let i = start; i < s.length; i++) {
      if (s[i] === '{') depth++;
      else if (s[i] === '}') { depth--; if (depth === 0) return i; }
    }
    return -1;
  }

  function splitTopLevel(s, sep) {
    const parts = [];
    let depth = 0;
    let current = '';
    for (let i = 0; i < s.length; i++) {
      const ch = s[i];
      if (ch === '(' || ch === '{' || ch === '[') depth++;
      else if (ch === ')' || ch === '}' || ch === ']') depth--;
      if (ch === sep && depth === 0) {
        parts.push(current);
        current = '';
      } else {
        current += ch;
      }
    }
    if (current) parts.push(current);
    return parts;
  }

  function findTopLevelPipe(s) {
    let depth = 0;
    for (let i = 0; i < s.length; i++) {
      const ch = s[i];
      if (ch === '(' || ch === '{' || ch === '[') depth++;
      else if (ch === ')' || ch === '}' || ch === ']') depth--;
      if (ch === '|' && depth === 0) return i;
    }
    return -1;
  }

  // --- UI ---

  const EXAMPLES = [
    {
      name: 'Tailwind Dashboard',
      fullFile: true,
      code: `import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Avatar } from "@/components/ui/avatar"

interface Stat {
  label: string
  value: string
}

interface Activity {
  title: string
  time: string
  status: string
}

interface DashboardProps {
  user: { name: string; avatar: string }
  initialStats: Stat[]
  initialActivities: Activity[]
}

export default function Dashboard({ user, initialStats, initialActivities }: DashboardProps) {
  const [stats] = useState(initialStats)
  const [activities] = useState(initialActivities)

  return (
    <div className="flex flex-col min-h-screen bg-gray-50">
      <header className="flex items-center justify-between px-6 py-4 bg-white shadow-sm">
        <h1 className="text-xl font-bold text-gray-900">Dashboard</h1>
        <div className="flex items-center gap-3">
          <Button className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700">
            New Project
          </Button>
          <Avatar className="w-8 h-8 rounded-full" src={user.avatar} />
        </div>
      </header>
      <main className="flex-1 p-6">
        <div className="grid grid-cols-3 gap-6 mb-8">
          {stats.map(stat => (
            <div className="p-6 bg-white rounded-lg shadow-sm">
              <p className="text-sm font-medium text-gray-500">{stat.label}</p>
              <p className="mt-2 text-3xl font-bold text-gray-900">{stat.value}</p>
            </div>
          ))}
        </div>
        <div className="bg-white rounded-lg shadow-sm">
          <div className="px-6 py-4 border-b border-gray-200">
            <h2 className="text-lg font-medium text-gray-900">Recent Activity</h2>
          </div>
          <ul className="divide-y divide-gray-200">
            {activities.map(item => (
              <li className="flex items-center justify-between px-6 py-4">
                <div className="flex items-center gap-3">
                  <div className="w-8 h-8 rounded-full bg-gray-200" />
                  <div>
                    <p className="text-sm font-medium text-gray-900">{item.title}</p>
                    <p className="text-sm text-gray-500">{item.time}</p>
                  </div>
                </div>
                <span className="px-2 py-1 text-xs font-medium text-green-700 bg-green-100 rounded-full">
                  {item.status}
                </span>
              </li>
            ))}
          </ul>
        </div>
      </main>
    </div>
  )
}`,
    },
    {
      name: 'Simple HTML',
      code: `function LandingPage() {
  return (
    <div id="root">
      <nav>
        <a href="/">Home</a>
        <a href="/about">About</a>
        <a href="/contact">Contact</a>
      </nav>
      <main>
        <h1>Welcome to our site</h1>
        <p>This is a simple landing page with basic HTML elements.</p>
        <form>
          <label>Email</label>
          <input type="email" placeholder="you@example.com" />
          <label>Password</label>
          <input type="password" placeholder="Enter password" />
          <button type="submit">Sign In</button>
        </form>
        <img src="hero.jpg" alt="Hero image" />
      </main>
      <footer>
        <p>Copyright 2024</p>
      </footer>
    </div>
  );
}`,
    },
    {
      name: 'Conditionals',
      fullFile: true,
      code: `import { Spinner } from "@/components/ui/spinner"
import { Alert, AlertTitle, AlertDescription } from "@/components/ui/alert"
import { Avatar } from "@/components/ui/avatar"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { EmptyState } from "@/components/ui/empty-state"
import type { User } from "@/types"

interface UserProfileProps {
  user: User | null
  isLoading: boolean
  error: Error | null
  onClearError: () => void
  onLogin: () => void
}

export default function UserProfile({ user, isLoading, error, onClearError, onLogin }: UserProfileProps) {
  return (
    <div className="profile-container">
      {isLoading && (
        <Spinner size="large" />
      )}
      {error && (
        <Alert type="error" onDismiss={onClearError}>
          <AlertTitle>Something went wrong</AlertTitle>
          <AlertDescription>{error.message}</AlertDescription>
        </Alert>
      )}
      {user ? (
        <div className="profile-card">
          <Avatar src={user.avatar} size="xl" />
          <h2 className="profile-name">{user.name}</h2>
          <p className="profile-bio">{user.bio}</p>
          {user.isAdmin ? (
            <Badge variant="admin">Admin</Badge>
          ) : (
            <Badge variant="user">User</Badge>
          )}
        </div>
      ) : (
        <EmptyState
          title="No user found"
          description="Please log in to view your profile"
          action={<Button onClick={onLogin}>Log In</Button>}
        />
      )}
    </div>
  );
}`,
    },
    {
      name: 'Form + Validation',
      fullFile: true,
      code: `"use client"

import { useState } from "react"
import { FormField } from "@/components/ui/form-field"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"

interface CheckoutFormProps {
  onSubmit: (values: Record<string, string>) => Promise<void>
}

export default function CheckoutForm({ onSubmit }: CheckoutFormProps) {
  const [values, setValues] = useState({ name: "", email: "", card: "", expiry: "", cvc: "" })
  const [errors, setErrors] = useState<Record<string, string>>({})
  const [isProcessing, setIsProcessing] = useState(false)

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setValues(prev => ({ ...prev, [e.target.name]: e.target.value }))
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsProcessing(true)
    await onSubmit(values)
    setIsProcessing(false)
  }

  return (
    <form className="checkout-form" onSubmit={handleSubmit}>
      <FormField label="Full Name" error={errors.name}>
        <Input name="name" value={values.name} onChange={handleChange} placeholder="John Doe" />
      </FormField>
      <FormField label="Email" error={errors.email}>
        <Input name="email" type="email" value={values.email} onChange={handleChange} placeholder="john@example.com" />
      </FormField>
      <FormField label="Card Number" error={errors.card}>
        <Input name="card" value={values.card} onChange={handleChange} placeholder="4242 4242 4242 4242" />
      </FormField>
      <div className="checkout-row">
        <FormField label="Expiry" error={errors.expiry}>
          <Input name="expiry" value={values.expiry} onChange={handleChange} placeholder="MM/YY" />
        </FormField>
        <FormField label="CVC" error={errors.cvc}>
          <Input name="cvc" value={values.cvc} onChange={handleChange} placeholder="123" />
        </FormField>
      </div>
      <Button type="submit" disabled={isProcessing} className="checkout-btn">
        {isProcessing ? "Processing..." : "Pay Now"}
      </Button>
    </form>
  )
}`,
    },
    {
      name: 'Full File',
      fullFile: true,
      code: `"use client"

import React, { useState, useEffect, useCallback, useMemo } from "react"
import { useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Card, CardHeader, CardBody } from "@/components/ui/card"
import type { Product } from "@/types"

interface ProductListProps {
  initialProducts: Product[]
}

export default function ProductList({ initialProducts }: ProductListProps) {
  const router = useRouter()
  const [products, setProducts] = useState(initialProducts)
  const [search, setSearch] = useState("")
  const [isLoading, setIsLoading] = useState(false)

  const filteredProducts = useMemo(() => {
    return products.filter(p => p.name.includes(search));
  }, [products, search])

  const handleDelete = useCallback(async (id: string) => {
    await fetch("/api/products/" + id, { method: "DELETE" });
    setProducts(prev => prev.filter(p => p.id !== id));
  }, [])

  useEffect(() => {
    setIsLoading(true)
    fetch("/api/products").then(r => r.json()).then(setProducts).finally(() => setIsLoading(false))
  }, [])

  return (
    <div className="flex flex-col gap-6 p-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Products</h1>
        <Button onClick={() => router.push("/products/new")}>Add Product</Button>
      </div>
      <div className="flex flex-col gap-4">
        {filteredProducts.map(product => (
          <Card key={product.id}>
            <CardHeader>
              <h2 className="text-lg font-bold">{product.name}</h2>
            </CardHeader>
            <CardBody>
              <p className="text-sm text-gray-500">{product.description}</p>
              <div className="flex items-center gap-2 mt-4">
                <Button onClick={() => handleDelete(product.id)}>Delete</Button>
              </div>
            </CardBody>
          </Card>
        ))}
      </div>
    </div>
  )
}`,
    },
    {
      name: 'Component Heavy',
      fullFile: true,
      code: `import { useState, useCallback } from "react"
import { Layout } from "@/components/layout"
import { Sidebar } from "@/components/sidebar"
import { NavItem } from "@/components/nav-item"
import { Content } from "@/components/content"
import { PageHeader } from "@/components/page-header"
import { Card, CardHeader, CardTitle, CardBody, CardFooter } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { OrderRow } from "@/components/order-row"
import { HomeIcon, SettingsIcon, ProfileIcon } from "@/components/icons"
import type { Order } from "@/types"

interface AppProps {
  initialOrders: Order[]
}

export default function App({ initialOrders }: AppProps) {
  const [orders, setOrders] = useState(initialOrders)
  const [page, setPage] = useState(1)

  const handleSelect = useCallback((id: string) => {
    console.log("selected", id)
  }, [])

  const handleDelete = useCallback((id: string) => {
    setOrders(prev => prev.filter(o => o.id !== id))
  }, [])

  const loadMore = useCallback(async () => {
    const res = await fetch("/api/orders?page=" + (page + 1))
    const next = await res.json()
    setOrders(prev => [...prev, ...next])
    setPage(p => p + 1)
  }, [page])

  const handleReset = useCallback(() => {
    setOrders(initialOrders)
    setPage(1)
  }, [initialOrders])

  return (
    <Layout>
      <Sidebar>
        <NavItem icon={<HomeIcon />} label="Home" href="/" />
        <NavItem icon={<SettingsIcon />} label="Settings" href="/settings" />
        <NavItem icon={<ProfileIcon />} label="Profile" href="/profile" />
      </Sidebar>
      <Content>
        <PageHeader title="Welcome" subtitle="Manage your account" />
        <Card>
          <CardHeader>
            <CardTitle>Recent Orders</CardTitle>
          </CardHeader>
          <CardBody>
            {orders.map(order => (
              <OrderRow key={order.id} order={order} onSelect={handleSelect} onDelete={handleDelete} />
            ))}
          </CardBody>
          <CardFooter>
            <Button variant="primary" onClick={loadMore}>Load More</Button>
            <Button variant="ghost" onClick={handleReset}>Reset</Button>
          </CardFooter>
        </Card>
      </Content>
    </Layout>
  )
}`,
    },
  ];

  // --- Decode examples ---

  const DECODE_EXAMPLES = [
    {
      name: 'Basic Component',
      fullFile: true,
      code: `@I react: useState

export default Counter()
  @state count = 0
  ---
  .container
   h1 "Counter"
   p (count)
   button {onClick:() => setCount(count + 1)} "Increment"
   button {onClick:() => setCount(0)} "Reset"`,
    },
    {
      name: 'Map + Full File',
      fullFile: true,
      code: `"use client"
@I react: useState, useCallback
@I @/components/ui/button: Button
@I @/components/ui/card: Card, CardHeader, CardBody
@T @/types: Product

ProductListProps {
  initialProducts: Product[]
}

export default ProductList({ initialProducts }: ProductListProps)
  @state products = initialProducts
  @state search = ""

  handleDelete = useCallback(async (id) => {
    await fetch("/api/products/" + id, { method: "DELETE" });
    setProducts(prev => prev.filter(p => p.id !== id));
  }, [])
  ---
  @P onClick=k
  @S items-center=ic, font-bold=fb, flex-col=fc

  .flex.fc.gap-6.p-6
   .flex.ic.justify-between
    h1.text-2xl.fb "Products"
    Button {k:() => router.push("/products/new")} "Add Product"
   .flex.fc.gap-4
    *products > Card {key:product.id}
      CardHeader
       h2.text-lg.fb (product.name)
      CardBody
       p.text-sm.text-gray-500 (product.description)
       .flex.ic.gap-2.mt-4
        Button {k:() => handleDelete(product.id)} "Delete"`,
    },
    {
      name: 'Simple Snippet',
      code: `.nav
 a {href:/} "Home"
 a {href:/about} "About"
 a {href:/contact} "Contact"`,
    },
    {
      name: 'Tailwind Card',
      code: `@C Button=B
@P onClick=k
@S items-center=ic, font-bold=fb

.max-w-sm.rounded-lg.shadow-lg.p-6
 h2.text-xl.fb "Dashboard"
 p.text-gray-500 "Welcome back"
 .flex.ic.gap-4.mt-4
  B {k:handleEdit} "Edit"
  B {k:handleDelete, variant:ghost} "Delete"`,
    },
    {
      name: 'Conditionals',
      fullFile: true,
      code: `@I react: useState
@I @/components/ui/spinner: Spinner
@I @/components/ui/alert: Alert

export default UserProfile({ user, isLoading, error })
  ---
  .profile-container
   ?isLoading > Spinner {size:large}
   ?error > Alert {type:error} (error.message)
   ?user > .profile-card
    h2.profile-name (user.name)
    p.profile-bio (user.bio)`,
    },
  ];

  const HTML_EXAMPLES = [
    {
      name: 'Table',
      code: `<table class="data-table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Email</th>
      <th>Role</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Alice</td>
      <td>alice@example.com</td>
      <td>Admin</td>
    </tr>
    <tr>
      <td>Bob</td>
      <td>bob@example.com</td>
      <td>User</td>
    </tr>
  </tbody>
</table>`,
    },
    {
      name: 'Card Grid',
      code: `<div class="grid">
  <div class="card">
    <img src="img1.jpg" alt="Card 1" class="card-img">
    <div class="card-body">
      <h3 class="card-title">Project Alpha</h3>
      <p class="card-text">A description of the first project.</p>
      <a href="/projects/alpha" class="card-link">Learn more</a>
    </div>
  </div>
  <div class="card">
    <img src="img2.jpg" alt="Card 2" class="card-img">
    <div class="card-body">
      <h3 class="card-title">Project Beta</h3>
      <p class="card-text">A description of the second project.</p>
      <a href="/projects/beta" class="card-link">Learn more</a>
    </div>
  </div>
  <div class="card">
    <img src="img3.jpg" alt="Card 3" class="card-img">
    <div class="card-body">
      <h3 class="card-title">Project Gamma</h3>
      <p class="card-text">A description of the third project.</p>
      <a href="/projects/gamma" class="card-link">Learn more</a>
    </div>
  </div>
</div>`,
    },
    {
      name: 'Landing Page',
      code: `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Landing</title>
</head>
<body>
  <header>
    <nav class="nav-bar">
      <a href="/" class="nav-link">Home</a>
      <a href="/about" class="nav-link">About</a>
      <a href="/contact" class="nav-link">Contact</a>
    </nav>
  </header>
  <main>
    <h1>Welcome to our site</h1>
    <p>This is a simple landing page with basic HTML elements.</p>
    <img src="hero.jpg" alt="Hero image">
  </main>
  <footer>
    <p>Copyright 2024</p>
  </footer>
</body>
</html>`,
    },
    {
      name: 'Form',
      code: `<div class="container">
  <h2>Sign Up</h2>
  <form method="post" action="/signup">
    <div class="form-group">
      <label for="email">Email</label>
      <input type="email" id="email" name="email" placeholder="you@example.com" required>
    </div>
    <div class="form-group">
      <label for="password">Password</label>
      <input type="password" id="password" name="password" placeholder="Enter password" required>
    </div>
    <button type="submit" class="btn btn-primary" disabled>Create Account</button>
  </form>
</div>`,
    },
    {
      name: 'SVG Chart',
      code: `<svg xmlns="http://www.w3.org/2000/svg" width="400" height="300" viewBox="0 0 400 300">
  <rect width="400" height="300" rx="16" fill="#ffffff" stroke="#e5e7eb" stroke-width="1"></rect>
  <text x="24" y="36" font-family="system-ui" font-size="16" font-weight="600" fill="#111827">Monthly Revenue</text>
  <text x="24" y="56" font-family="system-ui" font-size="12" fill="#6b7280">Last 6 months</text>
  <g transform="translate(24, 80)">
    <line x1="0" y1="0" x2="0" y2="180" stroke="#e5e7eb" stroke-width="1"></line>
    <line x1="0" y1="180" x2="352" y2="180" stroke="#e5e7eb" stroke-width="1"></line>
    <line x1="0" y1="90" x2="352" y2="90" stroke="#f3f4f6" stroke-dasharray="4"></line>
    <rect x="16" y="120" width="40" height="60" rx="4" fill="#6366f1" opacity="0.8"></rect>
    <rect x="72" y="90" width="40" height="90" rx="4" fill="#6366f1" opacity="0.8"></rect>
    <rect x="128" y="60" width="40" height="120" rx="4" fill="#6366f1" opacity="0.8"></rect>
    <rect x="240" y="40" width="40" height="140" rx="4" fill="#6366f1" opacity="0.8"></rect>
    <rect x="296" y="20" width="40" height="160" rx="4" fill="#6366f1" opacity="0.8"></rect>
    <text x="36" y="198" text-anchor="middle" font-size="10" fill="#6b7280">Jul</text>
    <text x="92" y="198" text-anchor="middle" font-size="10" fill="#6b7280">Aug</text>
    <text x="148" y="198" text-anchor="middle" font-size="10" fill="#6b7280">Sep</text>
    <text x="260" y="198" text-anchor="middle" font-size="10" fill="#6b7280">Nov</text>
    <text x="316" y="198" text-anchor="middle" font-size="10" fill="#6b7280">Dec</text>
  </g>
</svg>`,
    },
  ];

  const HTML_DECODE_EXAMPLES = [
    {
      name: 'With DOCTYPE',
      code: `!DOCTYPE html

html {lang:en}
 head
  meta {charset:UTF-8}
  title "My Page"
 body
  header
   h1 "Hello World"
  main
   p "Welcome to my page."
   img {src:photo.jpg, alt:A photo}
   br
  footer
   p "Copyright 2024"`,
    },
    {
      name: 'Navigation',
      code: `nav.nav-bar
 a.nav-link {href:/} "Home"
 a.nav-link {href:/about} "About"
 a.nav-link {href:/contact} "Contact"`,
    },
    {
      name: 'Form',
      code: `.container
 h2 "Sign Up"
 form {method:post, action:/signup}
  .form-group
   label {for:email} "Email"
   input {type:email, id:email, name:email, placeholder:you@example.com, required}
  .form-group
   label {for:password} "Password"
   input {type:password, id:password, name:password, placeholder:Enter password, required}
  button.btn.btn-primary {type:submit, disabled} "Create Account"`,
    },
    {
      name: 'SVG Icon',
      code: `svg {xmlns:http://www.w3.org/2000/svg, viewBox:0 0 24 24, fill:none, stroke:currentColor, stroke-width:2, stroke-linecap:round, stroke-linejoin:round}
 circle {cx:12, cy:12, r:10}
 line {x1:12, y1:8, x2:12, y2:12}
 line {x1:12, y1:16, x2:12.01, y2:16}`,
    },
  ];

  let currentFullFile = false;
  let currentMode = 'encode'; // 'encode' | 'decode'
  let currentFormat = 'jsx'; // 'jsx' | 'html'

  const outputEl = document.getElementById('output');
  const errorEl = document.getElementById('error');
  const warningEl = document.getElementById('warning');
  const inputCharsEl = document.getElementById('input-chars');
  const outputCharsEl = document.getElementById('output-chars');
  const encodeBtn = document.getElementById('encode-btn');
  const inputLabelEl = document.getElementById('input-label');
  const outputLabelEl = document.getElementById('output-label');
  const statInputTok = document.getElementById('stat-input-tok');
  const statOutputTok = document.getElementById('stat-output-tok');
  const statSavedTok = document.getElementById('stat-saved-tok');
  const statPct = document.getElementById('stat-pct');
  const compressionFill = document.getElementById('compression-fill');

  // Create CodeMirror editor
  const editor = new EditorView({
    state: EditorState.create({
      doc: EXAMPLES[0].code,
      extensions: [
        keymap.of([
          ...defaultKeymap,
          { key: 'Mod-Enter', run: () => { run(); return true; } },
        ]),
        javascript({ jsx: true, typescript: true }),
        oneDark,
        bracketMatching(),
        closeBrackets(),
        EditorView.lineWrapping,
      ],
    }),
    parent: document.getElementById('editor-wrap'),
  });

  // --- JSXN validation ---

  function validateJSXNFile(code) {
    const warnings = [];
    const lines = code.split('\n');
    let inFunction = false;
    let inJSXBody = false;
    let fnIndent = -1;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmed = line.trim();
      const indent = line.length - line.trimStart().length;
      if (!trimmed) continue;

      // Track function blocks
      if (/^(export\s+(default\s+)?)?[A-Za-z_$][A-Za-z0-9_$]*\(/.test(trimmed) && indent === 0) {
        inFunction = true;
        inJSXBody = false;
        fnIndent = 0;
        continue;
      }

      // Detect @state/@ref outside function block
      if ((trimmed.startsWith('@state ') || trimmed.startsWith('@ref ')) && indent === 0) {
        warnings.push(`Line ${i + 1}: \`${trimmed.split(' ')[0]} ${trimmed.split(' ')[1]}\` — hooks should be indented under a function`);
        continue;
      }

      // Detect --- at wrong indentation
      if (trimmed === '---') {
        if (!inFunction || indent === 0) {
          warnings.push(`Line ${i + 1}: \`---\` separator outside a function block`);
        } else {
          inJSXBody = true;
        }
        continue;
      }

      // If we were in a function and hit a non-indented line (not a known top-level pattern)
      if (inFunction && indent === 0) {
        const isTopLevel = trimmed.startsWith('@I ') || trimmed.startsWith('@T ') ||
          trimmed.startsWith('"use ') || /^(export\s+)?[A-Z]/.test(trimmed);
        if (!isTopLevel) {
          // Looks like JSXN body that should be inside a function
          if (/^[.#?*_a-z]/.test(trimmed) || /^[A-Z][a-z]/.test(trimmed)) {
            warnings.push(`Line ${i + 1}: \`${trimmed.slice(0, 30)}${trimmed.length > 30 ? '...' : ''}\` — looks like JSX body but is at the top level (missing indentation?)`);
          }
          inFunction = false;
          inJSXBody = false;
        }
      }
    }

    return warnings;
  }

  function validateJSXNSnippet(code) {
    const warnings = [];
    const lines = code.split('\n');
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;
      let depth = 0;
      for (const ch of line) {
        if (ch === '{') depth++;
        else if (ch === '}') depth--;
      }
      if (depth !== 0) {
        warnings.push(`Line ${i + 1}: unbalanced braces`);
      }
    }
    return warnings;
  }

  function run() {
    const code = editor.state.doc.toString();
    errorEl.classList.remove('visible');
    errorEl.textContent = '';
    warningEl.classList.remove('visible');
    warningEl.textContent = '';

    const actionLabel = currentMode === 'encode' ? 'Encode' : 'Decode';

    if (!code.trim()) {
      outputEl.innerHTML = '';
      outputEl.classList.add('empty');
      outputEl.textContent = `Click "${actionLabel}" or press Cmd+Enter`;
      inputCharsEl.innerHTML = '';
      outputCharsEl.innerHTML = '';
      resetStats();
      return;
    }

    try {
      let result;
      if (currentMode === 'encode') {
        if (currentFormat === 'html') {
          const { output, errors } = encodeHTMLInline(code);
          result = output;
        } else {
          const { output, errors } = currentFullFile ? encodeFile(code) : encode(code);
          result = output;
          if (errors.length > 0) {
            const msgs = errors.map(e => `Line ${e.loc?.line ?? '?'}: ${e.message}`);
            warningEl.textContent = `Parse warning${errors.length > 1 ? 's' : ''}: ${msgs.join(' | ')}`;
            warningEl.classList.add('visible');
          }
        }
        outputEl.innerHTML = highlightJSXN(result);
      } else {
        if (currentFormat === 'html') {
          result = decodeHTMLFn(code);
          outputEl.innerHTML = result.split('\n').map(l => highlightJSXLine(l)).join('\n');
        } else {
          const warnings = currentFullFile ? validateJSXNFile(code) : validateJSXNSnippet(code);
          if (warnings.length > 0) {
            warningEl.textContent = `Syntax warning${warnings.length > 1 ? 's' : ''}: ${warnings.join(' | ')}`;
            warningEl.classList.add('visible');
          }
          result = currentFullFile ? decodeFileFn(code) : decodeFn(code);
          outputEl.innerHTML = result.split('\n').map(l => highlightJSXLine(l)).join('\n');
        }
      }

      outputEl.classList.remove('empty');

      const inLen = code.length;
      const outLen = result.length;

      const inTok = estimateTokens(code);
      const outTok = estimateTokens(result);

      inputCharsEl.innerHTML = `<span class="tok-value">~${inTok.toLocaleString()}</span> <span class="tok-label">tokens</span>`;
      outputCharsEl.innerHTML = `<span class="tok-value">~${outTok.toLocaleString()}</span> <span class="tok-label">tokens</span>`;

      if (currentMode === 'encode') {
        const saved = inLen - outLen;
        const pct = inLen > 0 ? ((saved / inLen) * 100) : 0;
        const savedTok = inTok - outTok;
        statInputTok.textContent = '~' + inTok.toLocaleString();
        statOutputTok.textContent = '~' + outTok.toLocaleString();
        statSavedTok.textContent = '~' + savedTok.toLocaleString();
        statPct.textContent = pct.toFixed(1) + '%';
        compressionFill.style.width = Math.max(0, Math.min(100, pct)) + '%';
        compressionFill.parentElement.setAttribute('aria-valuenow', Math.round(pct));
      } else {
        // In decode mode, show expansion ratio
        const expanded = outLen - inLen;
        const pct = outLen > 0 ? ((expanded / outLen) * 100) : 0;
        const expandedTok = outTok - inTok;
        statInputTok.textContent = '~' + inTok.toLocaleString();
        statOutputTok.textContent = '~' + outTok.toLocaleString();
        statSavedTok.textContent = '~' + expandedTok.toLocaleString();
        statPct.textContent = pct.toFixed(1) + '%';
        compressionFill.style.width = Math.max(0, Math.min(100, pct)) + '%';
        compressionFill.parentElement.setAttribute('aria-valuenow', Math.round(pct));
      }
    } catch (e) {
      errorEl.textContent = e.message;
      errorEl.classList.add('visible');
    }
  }

  function resetStats() {
    statInputTok.textContent = '—';
    statOutputTok.textContent = '—';
    statSavedTok.textContent = '—';
    statPct.textContent = '—';
    compressionFill.style.width = '0%';
    compressionFill.parentElement.setAttribute('aria-valuenow', 0);
  }

  function loadExample(idx) {
    const examples = currentFormat === 'html'
      ? (currentMode === 'encode' ? HTML_EXAMPLES : HTML_DECODE_EXAMPLES)
      : (currentMode === 'encode' ? EXAMPLES : DECODE_EXAMPLES);
    const ex = examples[idx];
    currentFullFile = !!ex.fullFile;
    editor.dispatch({
      changes: { from: 0, to: editor.state.doc.length, insert: ex.code },
    });
    document.querySelectorAll('.example-btn').forEach((btn, i) => {
      btn.classList.toggle('active', i === idx);
    });
    run();
  }

  function buildExampleButtons() {
    const examplesBar = document.querySelector('.examples');
    // Remove old buttons (keep the label)
    examplesBar.querySelectorAll('.example-btn').forEach(b => b.remove());
    const examples = currentFormat === 'html'
      ? (currentMode === 'encode' ? HTML_EXAMPLES : HTML_DECODE_EXAMPLES)
      : (currentMode === 'encode' ? EXAMPLES : DECODE_EXAMPLES);
    examples.forEach((ex, i) => {
      const btn = document.createElement('button');
      btn.className = 'example-btn';
      btn.textContent = ex.name;
      btn.addEventListener('click', () => loadExample(i));
      examplesBar.appendChild(btn);
    });
  }

  // Mode switching
  function updateLabels() {
    const fmt = currentFormat === 'html' ? 'HTML' : 'JSX';
    if (currentMode === 'encode') {
      inputLabelEl.textContent = `${fmt} input`;
      outputLabelEl.textContent = 'JSXN output';
      encodeBtn.textContent = 'Encode';
      document.getElementById('stat-saved-label').textContent = 'saved';
    } else {
      inputLabelEl.textContent = 'JSXN input';
      outputLabelEl.textContent = `${fmt} output`;
      encodeBtn.textContent = 'Decode';
      document.getElementById('stat-saved-label').textContent = 'expanded';
    }
  }

  window.setMode = function(mode) {
    if (mode === currentMode) return;
    currentMode = mode;

    document.getElementById('mode-encode').classList.toggle('active', mode === 'encode');
    document.getElementById('mode-decode').classList.toggle('active', mode === 'decode');
    document.getElementById('mode-encode').setAttribute('aria-pressed', mode === 'encode');
    document.getElementById('mode-decode').setAttribute('aria-pressed', mode === 'decode');

    updateLabels();
    buildExampleButtons();
    loadExample(0);
  };

  window.setFormat = function(fmt) {
    if (fmt === currentFormat) return;
    currentFormat = fmt;

    document.getElementById('fmt-jsx').classList.toggle('active', fmt === 'jsx');
    document.getElementById('fmt-html').classList.toggle('active', fmt === 'html');
    document.getElementById('fmt-jsx').setAttribute('aria-pressed', fmt === 'jsx');
    document.getElementById('fmt-html').setAttribute('aria-pressed', fmt === 'html');

    updateLabels();
    buildExampleButtons();
    loadExample(0);
  };

  encodeBtn.addEventListener('click', run);

  // Check URL hash for initial mode/format
  if (window.location.hash === '#decode') {
    setMode('decode');
  } else if (window.location.hash === '#html') {
    setFormat('html');
  } else {
    buildExampleButtons();
    loadExample(0);
  }
</script>
</body>
</html>
